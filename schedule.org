* before 1.0.0
** TODO render worker(7d)
*** worker->init, loop
*** no worker
*** user can add job

** TODO texture(4d)
*** basic texture
**** TODO show texture
**** TODO load texture
**** TODO support hot load texture
*** diffuse, specular texture

** TODO load .wd(7d)
*** add transform->rotation, scale
*** load .wd(refer to glsf 2.0)
*** data-oriented
*** converter
**** .obj



** TODO event (4d)
*** pc event
*** mobile event

** TODO picking(2d)

** TODO camera(2d)

*** ortho camera


*** arcball camera controller








*** fly camera controller





** TODO mobile(3d)
*** TODO Multiresolution adaptation


*** TODO add mobile render pipeline


* after 1.0.0
** TODO [#A] script component(7d)
*** hot load


*** support import other script

** TODO [#A] support webgl2
*** TODO improve instance
refer to http://www.jiazhengblog.com/blog/2017/03/20/3104/ -> comment:
事实上在 webgl2 当中，可以直接使用 gl.vertexAttribDivisor 来直接完成实例化数组了，


*** TODO defer shading

**** TODO point light
add dirty?


*** TODO vao
optimize: judge last sended vao buffer



*** TODO ubo
*** TODO glsl 3.0

no need to compile!? but need to learn babyonjs compiler firstly!!!
/*
wonder-glsl-compiler should support convert glsl 2.0 to 3.0!!!???

refer to babylonjs(source code):
http://doc.babylonjs.com/features/webgl2#multisample-render-targets
Shaders
When WebGL2 is enabled, the shaders are automatically converted to GLSL v3.0. Babylon.js will then automatically take
advantage of extended instruction/uniform counts. 

*/




*** TODO Occlusion Queries
*** TODO more?






** TODO [#C] finish book draft
take about 60 days to finish




** TODO [#B] dynamic load asset

refer to unity->AssetBundle:
https://docs.unity3d.com/Manual/AssetBundlesIntro.html
http://gad.qq.com/article/detail/10033


** TODO [#A] extend

*** TODO extend files
extend material(? material asset?), shader(.glsl), job(.js), script(.js), config data(.json->./Wonder.js/data/ json files)


extend service(.js?)





add config(.json) to specific the file structure in project file(.wd_project_package)


*** TODO use .wonder_extend_package package(zip file) to include all extend files

include asset:
e.g.:
.wd
.bin
...









*** TODO extend render config

**** TODO improve shaders.json->branch(static_branch)
remove static_branchs, change to:
        {
          "type": "static_branch",
          "name": "modelMatrix_instance"
        },


add Shaders.re->addBranchHandle api, user can register handle after load(e.g. wd.addBranchHandle("modelMatrix_instance", function(xxx){...}))


**** TODO add custom material+custom shader
***** TODO custom glsl can support instance



**** TODO user can write own .glsl can register to npm
modify render config(shader config json?), support build npm->glsl to ShaderChunk.ts?





**** TODO extend material
user can add custom material, custom glsl, custom shaderLib_generate, custom render module(like defer, front render
module/system)
////(but how to handle render worker?)


user can edit shaders.json, shader_libs.json(e.g. add condition limit so that use one shader lib when in mobile, use
other one when in pc)




**** TODO extend glsl

***** TODO glsl use require,include?
@bhouston what about a custom webpack loader for the glsl files instead of using the raw-loader? The loader could take care of recursively resolving any #include lines in the root shader file. Any shader could be required in with e.g.:

var vert = require('three-glsl!../shaders/my-shader.vert')
var frag = require('three-glsl!../shaders/my-shader.frag')
just a thought








*** TODO extend component
/*
user can write local/public component

add wonder_component_config.json, add "components" field.
e.g.
{
components:[
"wonder-component-aaa"
]
}

wonder should read this field and register it


public component:
(refer to typescript=>d.ts)
user should send it to public github repository
in ci, it will check and run unit test

after pass ci and merge it, it will be published to @wonder-components/xxx npm package 
*/

**** TODO add script component
http://docs.cocos.com/creator/manual/zh/scripting/

now one script is one component(the type is user script component)

editor should show it in inspector(the component name should be defined by script json)

one gameObject can has multiple user script components(only has one? or has multiple?):
declare properties(can be show and edit in editor)

implement interface functions(.rei), e.g.:
onDispose
...



refer to:
https://developer.playcanvas.com/en/user-manual/scripting/



***** TODO support Hot Reloading 
https://developer.playcanvas.com/en/user-manual/scripting/hot-reloading/

https://developer.playcanvas.com/zh/ukser-manual/introduction/



***** TODO support import other script
http://docs.cocos.com/creator/manual/zh/scripting/modular-script.html


***** TODO for editor->"edit and run" feature

should invoke editor exposed api instead of directly invoke engine's api!
(
because if user add box in script, should update ui(e.g. scene tree)!
)


**** TODO add custom component
declare properties(can be show and edit in editor)



implement interface functions(.rei), e.g.:
update
dispose
clone
add
...
( component add and implement .rei)



how to add component data to state???



accept function string which is inputed from editor!
use "new Function"?


can use job for manage custom component(e.g. add "updateXXX" for update logic)
*** TODO work in editor
work in editor


work with editor ->extension ui component?
*** TODO solve how to extend by user:(refer to unity)


how to write own component
how to write own extension(material)
build component repository?









*** TODO extend job
add user job in json


** TODO publish




** TODO skybox



** TODO [#A] UI

stop loop:
should not stop ui loop logic!!!


*** TODO 2d UI
**** TODO loading ui

***** TODO support custom loading ui

*** TODO 3d UI





*** TODO extend ui




** TODO advanced debug

*** TODO show debug info
setting.json add:
debug: {
    open_contract_check: true,
    show_debug_info: true
}



show worker, main fps


show worker, main memeory


show total fps,render time


show each job's render time, memory


*** TODO can log error,fatal state json data(when open debug). we can reproduce the bug by the json data!!!



** TODO add tag, name


** TODO advanced job
*** TODO user can define job in json, add register job function by js

*** TODO job(or all data) support hot loading
setting.json add:
debug: {
    ...,
    hot_update_data: true
}



add isDirty flag

in each frame
    if dirty, re-generate job graph

*** TODO user can add job
**** TODO worker
***** TODO support user add worker job(in render/cull/... worker)

////***** TODO support user added worker job to new worker

add worker pool



window.navigator.hardwareConcurrency

make sure only hardwareConcurrency jobs can be used(in each worker)!else jobs should be wait




////***** TODO support add worker job at runtime(can add to different/new worker)












** TODO schedule frame rate(define in json config)
**** TODO can specify fps 
e.g.
keep 60/40/30 fps

**** TODO can specify worker fps 
e.g. 
main worker: 1 frame sync(must sync at each frame)
render worker: 2 frame sync
physics worker: 1 frame sync
xxx worker: 3 frame sync


** TODO e2e test for multi thread




** TODO [#B] Voxel
https://interplayoflight.wordpress.com/2015/04/08/the-rendering-technology-of-skysaga-infinite-isles/
*** TODO voxel terrain
https://www.youtube.com/watch?v=51JNyjBcDMo

https://forum.unity.com/threads/terrainengine-voxel-terrain-smooth-cubic-2d-hexagonal-infinite-procedural-terrain.174595/


marching cube
destruct, dig hole
lod
multi materials(multi layer)

voxel billboard?(for tree, grass)

triplanar mapping




*** TODO voxel model(which can be destruct)(static?)
marching cube

**** TODO generate a new uv map of a new polygon model generated by a voxel model(marching cube?) which can map the same texture of the origin polyon model's
voxel farm:

http://procworld.blogspot.com/2016/05/applying-textures-to-voxels.html
***** We had to write voxelization routines that captured the UV data with no ambiguities.



***** we had to make sure our dual contouring methods could output the UV data back into triangle form.

The realtime compression had to be now aware of the UV space, and remain fast enough for realtime use.
And last but not least we knew voxel content would be edited and modified in many sorts of cruel ways. We had to understand how the UV data would survive (or not) all these
transformations. 

***** internal voxels do not have UV info, but a regular material that is exposed when the surface voxels are gone.
***** Only the surface voxels have UVs.






Rethinking Texture Mapping:
http://www.cemyuksel.com/courses/conferences/siggraph2017-rethinking_texture_mapping/rethinking_texture_mapping_course_notes.pdf



volume-encoded-uv-maps
http://vcg.isti.cnr.it/volume-encoded-uv-maps/volume-encoded-uv-maps.pdf
http://vcg.isti.cnr.it/volume-encoded-uv-maps/volume-encoded-uv-maps_additional.pdf
http://vcg.isti.cnr.it/volume-encoded-uv-maps/



tileTrees
https://www-sop.inria.fr/reves/Basilic/2007/LD07/LD07.pdf
https://www-sop.inria.fr/reves/Basilic/2008/DL08/



octree texture
http://www.antexel.com/sylefeb/octreetex/
http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/DeBry02.pdf
http://www.cs.jhu.edu/~misha/ReadingSeminar/Papers/Benson02.pdf



Examining Automatic Texture Mapping of Arbitrary Terrains: https://www.diva-portal.org/smash/get/diva2:422722/FULLTEXT01.pdf


should learn from book:
《TEXTURING And MODELING A Procedural Approach》


polycube map:
http://vcg.isti.cnr.it/polycubemaps/


Perfect Spatial Hashing:
http://hhoppe.com/perfecthash.pdf
https://github.com/Jinxit/psh




need study:
Unified Texture Management for Arbitrary Meshes: http://evasion.inrialpes.fr/Publications/2004/LDN04/RR-5210.pdf






***** TODO references
https://emnh.github.io/rts-blog/2017/04/25/10_voxelization.html
Examining Automatic Texture Mapping of Arbitrary Terrains: https://www.diva-portal.org/smash/get/diva2:422722/FULLTEXT01.pdf


**** TODO construct examples in game
In Infinity: Battlescape, we designed our space stations, bases and factories to be modular. This means that we model &
texture independant modules, which can get attached together in various configuration layouts. Here's one of such
layouts for a space station: https://www.gamedev.net/blogs/entry/2262351-patch-0160-screenshots/

https://www.youtube.com/watch?v=DQg6mpjQMRo&feature=youtu.be












** TODO [#C] add ray tracing pipeline

refer to DXR: 
https://blogs.msdn.microsoft.com/directx/2018/03/19/announcing-microsoft-directx-raytracing/
https://www.zhihu.com/question/269149582
https://devblogs.nvidia.com/introduction-nvidia-rtx-directx-raytracing/



** TODO [#B] optimize
*** TODO compress typeArrays
e.g. Texture typeArray->wrapS, wrapT, ... should share the same Uint8Array with different value range



* Tool
** TODO webgl inspector which can work with multi thread
