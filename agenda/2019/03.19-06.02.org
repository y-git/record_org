* 今日计划
** TODO mickey
*** TODO feat(website): add link for feature



*** TODO feat(ui): write message ui


** TODO engine script
*** TODO support change property in inspector(editor)

在代码中我们不需要关心这些数值是多少，因为我们之后会直接在 属性检查器 中设置这些数值。

这些数值都是建议，一会等游戏运行起来，您完全可以按照自己的喜好随时在 属性检查器 中修改这些数值，不需要改动任何代码，很方
便吧！ 



http://docs.cocos.com/creator/manual/zh/scripting/use-component.html


*** TODO 扩展 Inspector
http://docs.cocos.com/creator/manual/zh/extension/extends-inspector.html

editor can extend user script component's inspector!



*** TODO support hot edit script


*** TODO support js


*** TODO support reason?
can add compiler in front end for user to compile reason to js???




** TODO job script, data json

*** TODO data json
open/close worker setting



**** TODO user can change setting.json->buffer
1.editor->engine->setting.json
2.publish->engine->setting.json





*** TODO editor: support edit config json

*** TODO job
**** TODO fix bug:
action->before not worker???
**** TODO support import/export job script
***** TODO wdb

***** TODO generate



*** TODO demo
**** TODO 3d snake







* 完成事项
** DONE learn data
CLOSED: [2019-03-23 Sat 09:29]



** DONE implement engine script
CLOSED: [2019-03-26 Tue 18:07]
*** DONE draft
CLOSED: [2019-03-24 Sun 17:16]

*** DONE pass run test
CLOSED: [2019-03-24 Sun 17:16]


*** DONE exec init event function
CLOSED: [2019-03-24 Sun 17:36]


*** DONE pass run test
CLOSED: [2019-03-24 Sun 17:36]


*** DONE change transform in update
CLOSED: [2019-03-25 Mon 09:20]

pass run test





*** DONE handle dispose
CLOSED: [2019-03-26 Tue 10:23]

add dispose event function


*** DONE handle clone
CLOSED: [2019-03-26 Tue 11:19]
not share script component

share attribte,event function(but with new instance)


no need to clone script attribute, because it's immutable.





*** DONE worker
CLOSED: [2019-03-26 Tue 11:56]
exec script in main worker




*** DONE pass u,i test
CLOSED: [2019-03-26 Tue 18:06]
//pass all tests


//test init job

//test update job

//test change transform in update


//test dispose

////test update and dispose(job order related)

//test clone:
reset value
add "test immutable change value case"








**** DONE test redo/undo
CLOSED: [2019-03-26 Tue 17:38]
***** TODO test change script attribute(immutable)




**** DONE test worker
CLOSED: [2019-03-26 Tue 18:00]




commit





** DONE implement editor script
CLOSED: [2019-04-11 Thu 10:27]




*** DONE engine
CLOSED: [2019-03-29 Fri 08:00]
//script attribute



//script



script event function:
//event function can be undefined

////split ?


//add get all



//add enable/disable script



//test






//finish TODO


*** DONE fix jest
CLOSED: [2019-03-29 Fri 10:58]
not warn!

upgrade jest to 24.3.1


*** TODO think
two script node:
name
data

add remove

add enable/disable all script event function

editor->engine service->init,dispose gameObject/script should disable




show/edit script component->attribute fields in inspector:
add set default value and value

(check in editor: value should equal default value)



change asset->attribute fields:
add/remove should affect script component->attribute

edit shouldn't affect script component->attribute





shouldn't add/remove script component->attribute fields (only allow edit)





change asset->event functions should update script component->event functions




*** DONE add script asset
CLOSED: [2019-03-29 Fri 16:47]

should check name unique


*** DONE script asset->inspector
CLOSED: [2019-03-30 Sat 21:27]




*** DONE test
CLOSED: [2019-04-02 Tue 21:32]
//pass script event function


//fix material node



pass script attribute:
//fix field
//submit field
//remove field



//commit

*** DONE fix: rename script event function(not change, blur) shouldn't alert!
CLOSED: [2019-04-03 Wed 09:00]



*** DONE fix: rename script attribute(not change, blur) shouldn't alert!
CLOSED: [2019-04-03 Wed 09:01]




*** DONE field name should be unique(add check)
CLOSED: [2019-04-03 Wed 10:14]



*** DONE fix: rename script attribute field shouldn't change entries order
CLOSED: [2019-04-03 Wed 10:14]
should sort entries by field name







*** DONE add check asset->inspector->jsObj(shouldn't fatal!)
CLOSED: [2019-04-03 Wed 11:42]







*** DONE add script component
CLOSED: [2019-04-05 Fri 09:44]
**** DONE event function
CLOSED: [2019-04-04 Thu 16:34]

draft:
//select event function
//refactor


//should warn





//test:
//remove 





//fix: should contain self


//fix: should refresh



//test


//add remove 





**** DONE attribute
CLOSED: [2019-04-04 Thu 19:06]


//select attribute


show/edit fields:
//draft


//test set default value


//fix: switch  should refresh











**** DONE finish "update script component logic"
CLOSED: [2019-04-04 Thu 22:07]
if type equal, not change default value and value


add should update


remove should update


rename should update


fix: add field in asset should refresh


test


**** DONE finish "update script component logic with script event function"
CLOSED: [2019-04-05 Fri 09:42]








*** DONE refactor
CLOSED: [2019-04-05 Fri 21:14]
//pass all tests


use SelectGroupXXX:

//material


////material->map->select texture


//MainEditorScript->event function


//commit






//refactor: extract duplicate with ForAdd













//split MainEditorScript:
split event function(to be ui)
split attribute(to be ui)



extract more ui:
//select group ui
//MainEditorTextComponent(atom ui)
...



*** DONE refactor: rename Item to Asset
CLOSED: [2019-04-06 Sat 09:39]



*** DONE pass run/stop
CLOSED: [2019-04-07 Sun 10:15]


////change init to start


draft:
//shouldn't update when stop->loopBody


////fix: unsafeGetScriptGameObject in update event function




//api should update editor!(not redo-undo)


////fix: other refresh(except getAndRefreshEngineStateForRunLoop) should disable and restore script!


//test redo-undo when run/stop




//refactor: change Controller_runStop_script_test to integration test





//support change event function when run



////test use attribute


//support change script component->field->default when run












**** TODO run test



**** TODO u,i test

//test worker when run


//test redo-undo when run/stop

//test:
shouldn't change script component->field->default when run!



//test initXXX,disposeXXX not work


*** DONE remove script asset
CLOSED: [2019-04-07 Sun 15:14]

**** DONE finish "update script component logic by remove script event function/script attribute asset"
CLOSED: [2019-04-07 Sun 15:14]




*** DONE test
CLOSED: [2019-04-07 Sun 15:14]




*** DONE redo-undo
CLOSED: [2019-04-08 Mon 10:01]
**** DONE script asset inspector add redo-undo
CLOSED: [2019-04-07 Sun 17:57]


**** TODO script component add redo-undo
***** DONE event function add redo-undo
CLOSED: [2019-04-07 Sun 21:15]



***** DONE attribute add redo-undo
CLOSED: [2019-04-08 Mon 10:01]






*** DONE fix clone gameObject which has script component
CLOSED: [2019-04-07 Sun 20:19]



*** DONE update wonder-commonlib
CLOSED: [2019-04-08 Mon 10:49]




*** DONE finish all TODOS
CLOSED: [2019-04-08 Mon 11:33]
//move to wonder.js



*** DONE push to dev
CLOSED: [2019-04-08 Mon 11:53]



need test update



*** DONE pass test coverage
CLOSED: [2019-04-08 Mon 15:39]



*** DONE store in wdb(engine)
CLOSED: [2019-04-09 Tue 18:06]



**** DONE test
CLOSED: [2019-04-09 Tue 18:06]




*** DONE store in asb
CLOSED: [2019-04-10 Wed 12:12]


*** DONE import packasge->relate script assets
CLOSED: [2019-04-10 Wed 12:12]
relate asset wdb

relate scene wdb


*** DONE load wdb->extract script assets
CLOSED: [2019-04-10 Wed 12:12]

should check name 




*** DONE u,i test
CLOSED: [2019-04-10 Wed 20:53]

//test extract

//publish and update wonder.js version





*** DONE run test
CLOSED: [2019-04-11 Thu 10:02]



////** TODO feat(engine):  add clone between two state apis

*** DONE fix: rename attribute name
CLOSED: [2019-04-11 Thu 10:27]




** TODO finish 3d snake by editor
ui:
dom?
use imgui?



level

custom functions


private function in event function?



load prefab/asset when runtime



sync load scene

async load scene



ManageSceneAssetBundle: 
switch scene
load scene
unload scene
preload scene/load scene async
Additive/Single


separate load and add logic

loadScene is loadSceneAsync?return stream?


can get gameObject of loaded scene result





work with stream load?

work with whole load?




1.show/hide

add active api


2.switch scene
show loading bar:
http://www.alanzucconi.com/2016/03/30/loading-bar-in-unity/





asset bundle:
1.scene asset bundle(.sab)
like wdb

2.resource asset bundle(.rab):
/*
material
texture(image)
geometry?
script event function
script attribute
*/
like asb

rab should contain geometry asset instead of wdb asset?




assets add .sab, .rab assets



asset bundle can dependent on other one:
asset bundle = manifest + wdb/asb



sab can dependent on rab

rab can dependent on rab

sab can't dependent on sab




*** TODO load asset bundle
loadFromLocal


loadFromWeb



when publish, should commit asset bundles(by path)




*** TODO build asset bundle
create SelectTree ui, to select target


has option:
collectionDependency


*** TODO solve asset bundle->resource duplicate

1.not collectionDependency;
2.add total asset bundle(with manifest data->total dependencies data)





*** TODO add editor script to extend header



*** DONE how to reduce same data between scenes?
CLOSED: [2019-04-12 Fri 11:02]
use assetbundle?



only support set current active scene(not allow mutli scene editing)




SceneManager.loadScene will load all data????





*** TODO learn unity


*** TODO feat(engine): finish demo by load at once

**** DONE add active/unactive gameObject
CLOSED: [2019-04-13 Sat 18:23]
//not render

//not exec script



***** DONE add isRender,isActive(script), isActive(gameObject) to asset
CLOSED: [2019-04-13 Sat 18:23]



**** TODO finish demo by engine


***** DONE show first scene
CLOSED: [2019-04-13 Sat 20:33]



***** TODO show second scene->first level



***** TODO show second scene->second level



***** TODO show third scene



*** TODO use asset bundle

     TODO 
     add to scene (wait for stream if not finish)

     loading info




**** TODO design

for incremental load:
load asset bundle should get arraybuffer(asset bundle raw data);
use parseManifest, parseContent(not init, need user init);
add md5;





**** DONE build/import asset bundle in engine
CLOSED: [2019-04-27 Sat 11:13]


***** DONE finish logic
CLOSED: [2019-04-18 Thu 11:04]



***** DONE u,i test: test import case and pass whole test
CLOSED: [2019-04-25 Thu 10:52]
//pass all tests


check all logic from begin to end


add more client code




begin test:
//generateSingleRAB_test
//generateSingleSAB_test
//generateAllAB_test

//assemble test

load test:
//incremental load

...



//add progress test




***** DONE run test
CLOSED: [2019-04-26 Fri 12:24]
add to api


add to script api



//generate ab



use sab






run test:
//pass simple one;

//test merge->concat dependencies rabs;


//texture flipY not right?
//fix for generate wdb,sab,rab


//add flipY to WDType




//add addSABChildrenToScene



//test progress info




use rab:
//test script

////test material

...






***** DONE refactor:
CLOSED: [2019-04-26 Fri 16:57]
assemble sab


***** DONE run test: cache
CLOSED: [2019-04-26 Fri 22:11]
use indexdb



////***** TODO u,i test: add more detail tests



////***** TODO run test



////***** TODO refactor


////***** TODO benchmark



***** DONE merge load rabs and sab
CLOSED: [2019-04-27 Sat 10:56]



***** DONE rab,sab add isLoaded, isAssembled
CLOSED: [2019-04-27 Sat 10:56]




***** DONE test release rab/sab
CLOSED: [2019-04-27 Sat 11:13]



**** TODO editor
build asset bundle in editor(map to the type for build in engine)




***** DONE generate single rab
CLOSED: [2019-05-05 Sun 18:31]
select ui tree:
//draft pass compile
//show tree(with fake data)
could generate single rab:
    //show
    //lightMaterial->maps should contain in resourceData->textures
    //publish wonder.js npm and update version in editor





***** DONE generate single sab
CLOSED: [2019-05-06 Mon 09:40]


***** DONE refactor
CLOSED: [2019-05-06 Mon 10:05]
//remove log

//split


***** DONE generate single rab add name
CLOSED: [2019-05-06 Mon 11:20]



***** DONE assets support asset bundle
CLOSED: [2019-05-06 Mon 12:32]
asset tree add

load asset bundle


***** DONE u,i test
CLOSED: [2019-05-06 Mon 17:15]
//pass all tests

//add test cases:
test load
test inspector
test asset children





***** DONE run test
CLOSED: [2019-05-06 Mon 17:15]



***** DONE generate all abs
CLOSED: [2019-05-06 Mon 21:41]
draft
(pass compile)





***** DONE u,i test
CLOSED: [2019-05-07 Tue 11:24]
test generated all abs

test handle error(stream):
dependencyRelation str is wrong str
...




***** DONE run test
CLOSED: [2019-05-07 Tue 11:40]


***** DONE check in engine->run test
CLOSED: [2019-05-07 Tue 11:40]




***** DONE refactor
CLOSED: [2019-05-07 Tue 12:08]
duplicate

...










***** DONE pass "import ab at runtime when run"
CLOSED: [2019-05-16 Thu 12:29]
////finish draft


****** DONE rewrite script api->getAssetBundlePath
CLOSED: [2019-05-14 Tue 16:31]
******* TODO editor->init_script_api job rewrite it
add init_script_api job, rewrite it


****** DONE rewrite script api->cache apis
CLOSED: [2019-05-14 Tue 16:31]
******* TODO editor->init_script_api job rewrite it


****** DONE rewrite script api->load assetbundle
CLOSED: [2019-05-14 Tue 16:31]




****** DONE u,i test
CLOSED: [2019-05-16 Thu 12:29]
//rewrite addSABSceneGameObjectChildrenToScene, setSABSceneGameObjectToBeScene

//rewrite disposeSceneAllChildren

//rewrite setSABSceneGameObjectToBeScene:
fix current camera
pick in scene view




//commit



//add cache test cases



//commit



****** DONE run test
CLOSED: [2019-05-16 Thu 12:25]
pass run test

//remove _assetbundle_test


//update wonder.js version




***** DONE publish
CLOSED: [2019-05-17 Fri 19:03]

****** DONE write asset bundle to zip(draft)
CLOSED: [2019-05-17 Fri 11:34]
through select tree

****** DONE u,i test
CLOSED: [2019-05-17 Fri 12:37]


****** DONE run test
CLOSED: [2019-05-17 Fri 12:37]


****** DONE commit
CLOSED: [2019-05-17 Fri 12:37]




****** DONE refactor
CLOSED: [2019-05-17 Fri 12:58]
extract SelectTreeUtils.re



****** DONE commit
CLOSED: [2019-05-17 Fri 12:58]




****** DONE rewrite script api->getAssetBundlePath
CLOSED: [2019-05-17 Fri 16:55]
******* TODO editor->publish
add init_script_api job, rewrite it


****** DONE rewrite script api->cache apis
CLOSED: [2019-05-17 Fri 16:55]
******* TODO editor->publish



****** DONE need add scene wdb->root gameObject to scene
CLOSED: [2019-05-17 Fri 16:56]



****** DONE u,i test
CLOSED: [2019-05-17 Fri 16:56]


****** DONE pass run test
CLOSED: [2019-05-17 Fri 18:44]
//no worker

//worker


****** DONE commit
CLOSED: [2019-05-17 Fri 18:44]


****** DONE refactor:
CLOSED: [2019-05-17 Fri 19:03]
publish:
add commonForNoWorkerAndWorker.js



***** DONE fix import/export package
CLOSED: [2019-05-18 Sat 07:19]
****** DONE wpk support asset bundle
CLOSED: [2019-05-18 Sat 07:05]


****** DONE u,i test
CLOSED: [2019-05-18 Sat 07:05]


****** DONE pass run test
CLOSED: [2019-05-18 Sat 07:05]


****** DONE refactor
CLOSED: [2019-05-18 Sat 07:19]
split import package test







*** DONE feat(asset-bundle): more
CLOSED: [2019-05-19 Sun 09:16]
**** DONE support load all-ab zip to asset
CLOSED: [2019-05-19 Sun 09:16]



*** DONE add "new scene"
CLOSED: [2019-05-19 Sun 11:03]







*** DONE full test
CLOSED: [2019-05-19 Sun 15:08]
////add all cases


//finish "TODO test" in engine, editor





*** TODO feat(asset-bundle): merge script pr from @mickey
**** TODO check pr
**** TODO merge pr





*** TODO fix(editor): @mickey finded bug in new branch

fix (wdb -> generated image): 1.upload two wdbs; 2.switch click a1,a2 11times;
will lose texture!!!


**** DONE feat: add dispose basic source texture
CLOSED: [2019-05-20 Mon 13:22]

//add to group






**** DONE feat: add dispose array buffer view source texture 
CLOSED: [2019-05-20 Mon 13:22]


**** DONE u,i test
CLOSED: [2019-05-21 Tue 17:03]

/*!
  not dispose texture when dispose material!
  because different materials may use same texture, if dispose one material's texture which is shared, then will affect other materials!

  so need user mannually dispose texture!
  */


//test redo-undo



**** DONE pass worker
CLOSED: [2019-05-21 Tue 17:03]

//add needDisposedSourceArray?

//test



//fix arrayBufferViewSource texture



**** DONE fix dispose texture
CLOSED: [2019-05-23 Thu 17:56]





**** DONE test(wonder.js): pass test
CLOSED: [2019-05-24 Fri 08:25]





**** DONE fix textureInTypeArr
CLOSED: [2019-05-24 Fri 08:25]

fix init texture-> arrayBufferViewSource

fix more






**** DONE fix(editor): upload alphablendmodal twice, the snapshot is different!!!
CLOSED: [2019-05-24 Fri 16:34]


***** DONE u,i test
CLOSED: [2019-05-24 Fri 16:34]
test clearRect


**** DONE run test in editor
CLOSED: [2019-05-24 Fri 16:34]
//update dev branch to mickey:
//pass compile
////pass u,i test
pass run test







publish wonder.js version


update wonder.js, wonder-webgl version



run test


*** DONE test(wdb): pass all tests
CLOSED: [2019-05-24 Fri 16:34]



*** DONE test: pass all u,i tests
CLOSED: [2019-05-24 Fri 16:38]









*** DONE finish jiehuo demo
CLOSED: [2019-05-23 Thu 22:19]



*** DONE fix: Error: function (param) {
CLOSED: [2019-05-24 Fri 16:44]
                  return _node_modules_wonder_log_lib_es6_global_src_Log_js__WEBPACK_IMPORTED_MODULE_0__["buildFatalMessage"](param, "_convertPosition", "convertWorldToScreen return undefined", "", "");
                }



*** DONE fix: finish all TODOs
CLOSED: [2019-05-24 Fri 17:43]







////*** TODO test(wdb): add test cases





*** DONE fix: arcball: drag random
CLOSED: [2019-05-24 Fri 18:28]



*** DONE merge to dev
CLOSED: [2019-05-24 Fri 19:00]
//merge

//pass u,i tests


*** DONE fix(wdb inspector): click between elf_girl.zip,varina.zip : source is too large
CLOSED: [2019-05-25 Sat 17:36]

u,i test




*** DONE fix(imgCanvas): handle error(try/catch)
CLOSED: [2019-05-25 Sat 17:48]
e.g. cloneValueByGetOptionValueFunc


*** DONE fix(wdb inspector): should re-generate snapshot if material/texture change 
CLOSED: [2019-05-25 Sat 19:15]
in didMount



u,i test



*** DONE fix(material inspector): should re-generate snapshot
CLOSED: [2019-05-25 Sat 20:51]
in willUnMount


u,i test



////*** TODO fix: arcball: drag random(after drag wdb)

*** DONE fix: jiehuo
CLOSED: [2019-05-26 Sun 17:00]
update wonder-webgl


solve flipY


*** DONE optimize(editor): material/wdb inspector canvas: texImage2D spends too much time!!!     ???????
CLOSED: [2019-05-27 Mon 19:28]
////cache gl texture by texture name + image name???




**** DONE material inspector
CLOSED: [2019-05-27 Mon 19:28]
//cache texture 


//add disposeGameObject(...): not dispose texture, use remove instead


//publish and update wonder.js version






//if change texture asset,clear its cache:
wrap/filter / remove/dispose texture, import package, dispose single/all texture assets, 
init script api


**** DONE wdb inspector
CLOSED: [2019-05-27 Mon 19:28]
////cache wdb node id


test





**** DONE u,i test
CLOSED: [2019-05-27 Mon 19:28]






*** DONE fix(material->snapshot): remove wdb->material
CLOSED: [2019-05-27 Mon 16:17]
//should remove texture instead of dispose?
(add test case)



//fix bug:
add test case



*** DONE fix(asset): remove texture
CLOSED: [2019-05-27 Mon 17:39]

//dispose textures



*** DONE fix(undo): basic/array->glTextureMap
CLOSED: [2019-05-27 Mon 21:19]


*** DONE test: pass engine,editor all test cases
CLOSED: [2019-05-27 Mon 21:44]




*** DONE feat: add progress
CLOSED: [2019-05-29 Wed 07:28]
//show:
import package
load wdb


////export package



////add more detail percent


**** DONE refactor progress
CLOSED: [2019-05-29 Wed 07:28]



*** DONE feat(canvas-inspector): add camera for material, wdb
CLOSED: [2019-05-29 Wed 11:13]
**** DONE logic
CLOSED: [2019-05-28 Tue 16:34]

**** DONE u,i test
CLOSED: [2019-05-28 Tue 17:05]
////test arcball


**** DONE run test
CLOSED: [2019-05-28 Tue 17:05]


**** DONE refactor:
CLOSED: [2019-05-28 Tue 17:50]
remove duplicate



**** DONE fix:  focus before generate snapshot 
CLOSED: [2019-05-29 Wed 11:08]

//fix: wdb shouldn't affect material

fix: wdb shouldn't affect other wdb

////fix: add material; load wdb;  should correct



////**** TODO fix: setEventTarget(_convertDomEventToMouseEvent(MouseDown, event)) when mousemove?



**** DONE fix: totalLight += u_ambient;
CLOSED: [2019-05-29 Wed 11:13]
fix

set ambient color

*** DONE fix(inspectorCanvas):  1.load miku wdb 2.load miku wdb 3.load va wdb;   the va wdb in inspector canvas->material is wrong!
CLOSED: [2019-05-29 Wed 12:22]








*** TODO feat: finish demo by use asset bundle





*** TODO finish demo by load at once
**** TODO show first scene



**** TODO show second scene->first level



**** TODO show second scene->second level



**** TODO show third scene




**** TODO add more api
add bind event api?

add debug api, e.g.: 
api##Console##log


add get/set global function api?


**** TODO add dom ui(api need operate dom!)




** TODO finish jiehuo
*** DONE draw line
CLOSED: [2019-05-09 Thu 11:38]
**** TODO use box instead of line for demo


//TODO pass event target test



//TODO fix: drag over




**** TODO add line(canvas draw)
////***** TODO add custom material?

**** TODO dash line



**** TODO alpha



*** DONE test in mobile
CLOSED: [2019-05-09 Thu 17:10]



show slider






*** DONE add skybox(cubemap)
CLOSED: [2019-05-11 Sat 18:16]
//add job


//pass run test:
//show skybox in engine












*** DONE test in mobile
CLOSED: [2019-05-11 Sat 18:16]
////test line match problem


*** DONE fix dash line
CLOSED: [2019-05-11 Sat 19:06]




*** DONE draw mark(text)
CLOSED: [2019-05-12 Sun 08:10]


*** DONE add button
CLOSED: [2019-05-12 Sun 08:10]



*** DONE test in mobile
CLOSED: [2019-05-12 Sun 08:48]



*** DONE jump skybox
CLOSED: [2019-05-12 Sun 15:22]

////draw image(like text)


//click button, switch skybox



save skybox data




*** DONE test in mobile
CLOSED: [2019-05-12 Sun 15:22]

test in iphone


*** DONE show demo to ma
CLOSED: [2019-05-12 Sun 15:22]




*** DONE fix(iphone 6): slider not work
CLOSED: [2019-05-13 Mon 15:26]
use imgui


*** DONE optimize: loading
CLOSED: [2019-05-14 Tue 10:31]
print loading info

**** DONE optimize skybox
CLOSED: [2019-05-14 Tue 10:00]
//reduce size

//merge load


**** DONE show loading bar
CLOSED: [2019-05-14 Tue 10:31]
show percent


////add LoadManager?


////**** TODO optimize loading speed
change json to js object?



////*** TODO fix: qq browser can't show








////*** TODO fix: try to fix line rock...



*** DONE send demo to ma
CLOSED: [2019-05-14 Tue 10:49]




*** DONE fix(iphone 6): should prevent default
CLOSED: [2019-05-14 Tue 10:00]








** DONE fix(rotation): 
CLOSED: [2019-05-29 Wed 17:26]
////switch to new branch(need merge by @mickey)


180,90,180
0,90,0

+y can't work!!!




** DONE fix(inspectorCanvas): 1.add material. 2.select m1; 3.load wdb;   m1->snapshot is empty!!!
CLOSED: [2019-05-29 Wed 18:06]




** DONE fix(inspectorCanvas): fix default material snapshot
CLOSED: [2019-05-29 Wed 18:16]













** DONE refactor: rename "Scripts" to "Script"
CLOSED: [2019-05-29 Wed 18:19]









** DONE fix(script attribute-> inspector)(floatinput, intinput): drag field value(int/float) is wrong!!!
CLOSED: [2019-05-29 Wed 20:34]


** DONE fix(ui): mouse over FloatInput->drag zone should show handle cursor!
CLOSED: [2019-05-29 Wed 20:41]





////** TODO fix(console): expand error info, the arrow should change




** fix: add fatal(in console);    canvas will has blank!!!(in mac book->100%)









** DONE fix(asset): 1.dispose asset's folder; should dispose folder's all children assets!!!
CLOSED: [2019-05-30 Thu 11:40]


////** TODO fix: dispose wdb asset: the scene tree->cloned gameObjects should be removed!









////** TODO perf(inspector): material inspector->DiffuseMap: 1.show texture group; 2.each time, texture will be reload???    should load and cache data!!!












////** TODO benchmark


** DONE refactor: rename Result->SameDataResult->either to map
CLOSED: [2019-05-30 Thu 12:09]


////** TODO refactor(engine): remove service/record/data->StateMainDataType


** DONE find bugs
CLOSED: [2019-05-30 Thu 17:32]
*** DONE feat(inspector canvas): left button can drag
CLOSED: [2019-05-30 Thu 17:30]

////*** TODO feat(progress): show 100%

////*** TODO feat(progress): add progress when publish


*** DONE fix(new scene): 
CLOSED: [2019-05-30 Thu 16:56]
expect gameObject alive, but actual not




should work when stop;


                                                            


** TODO mickey
*** TODO generate asset image
**** DONE cull center range to generate
CLOSED: [2019-04-13 Sat 20:29]
***** TODO wdb need compute camera to make sure that the model is always fixed size


**** DONE optimize generate
CLOSED: [2019-04-13 Sat 20:29]
***** TODO compare save as base64 and uint8Array

**** TODO fix: remove texture; undo;    bug


**** TODO generate image for extracted materials from wdb



**** TODO save generated image(material, wdb) in wpk->asb






*** DONE code check
CLOSED: [2019-04-08 Mon 14:45]


**** DONE fix(resize): 1.enter editor;2.resize;3.show material inspector;    not render inspectorCanvas!
CLOSED: [2019-04-06 Sat 18:15]



**** DONE fix(setting): change setting.json(need commit)
CLOSED: [2019-04-05 Fri 10:08]


**** DONE fix(resize): 1.enter editor(small window);2.show material inspector;3.resize to big window;    shouldn't has blank!
CLOSED: [2019-04-08 Mon 14:45]


**** DONE feat: set ambient to (0.1,0.1,0.1)
CLOSED: [2019-04-08 Mon 14:45]

*** TODO feat: show progress bar when load asset, import package, export package, export wdb



*** TODO code check
**** TODO fix: should re-generate material image when remove its texture

















** TODO engine script

*** TODO design
global:
module(name)+function for user's functions

engine state add userRecord for user's shared data

set name+attribute/name+function for script attribute/file
(store in engine state->scriptRecord->?)








separate script attribute, function 


////script component has name(unique)


script component can attach multiple functions:
just list



function should be shared by name(global)



script component can attach multiple attributes:
each attribute is one instance for runtime



editor inspector->script show attributes:
if change "the same name attribute of different script component"->value, all of the name should be changed



**** user data are all immutable:
user's shared data are immutable
attributes are immutable

(convenient for redo/undo when run in editor)



add get/set each type attribute functions?




**** change attribute default value in editor
should enter refresh button after change


**** communicate runtime
////1.can change value through gameObject->script component->attribute name:
1.can change value through script component->attribute name:
only affect that instance


can find gameObject->get script component



2.global event





**** hot reload
should press "reload" button to reload.

add swap function:
will be invoked when press button
(no need to consider/restore about attribute)


init function will not be invoked


can change global->script functions/attributes or script component used which ones when run
(shouldn't effect if not press button!: 

editor should hold on these changes when run;
effect when press button;
)




***** TODO should add Edit->Controller Setting->"keep script function/attribute change when stop" checkbox!








*** TODO type:
script component:
attach script functions/attributes file/string?
//attach script files
show/edit attributes



script file:


script name(should be unique in script names)


script functions: hash map of functions


script attributes: hash map of any primitives type?(except function)





/*
script file: 


return {
name: 

getAttributes:  (attributeMap, addAttributeFunc) => {
////var attributeMap = createMap();

var attributeMap = addAttributeFunc("", {}, attributeMap);

return attributeMap;
},


init: (...) => {
},
update: (...) => {
},


};
*/




script function: 


return {
name: 

init: (...) => {
},
update: (...) => {
},
postUpdate: (...) => {
},
dispose: (...) => {
}

};








script attribute: 


return {
name: 

getAttributes:  (attributeMap, addAttributeFunc) => {
////var attributeMap = createMap();

var attributeMap = addAttributeFunc("", {}, attributeMap);

return attributeMap;
},



};



















{
type: "int",
array: false,
default: 0
}








*** TODO event functions
init

update

dispose

swap?



function is pure function???
(but operate engineState isn't pure!)


////should inject gameObject, (editorState, engineState), (scriptAPI, editorAPI, engineAPI) to params? 

should inject scriptComponent, (editorState, engineState), engineAPI to params? 


scriptAPI: operate script. e.g. get/set attribute, use other script's functions/attributes









*** TODO add initScript, updateScript jobs?
init script components in :
initScript job
init gameObject(after init all other components)


*** TODO attributes
attributes can't be added/removed in editor, only can be change value





*** TODO support one script import other one



*** TODO support multiple script files attached to one script component




*** TODO support script event?
dispose


*** TODO clone script component
////should share the same script component?


or only share the same script functions/attributes?


should create different instance of attributes





*** TODO support change property in inspector(editor)

在代码中我们不需要关心这些数值是多少，因为我们之后会直接在 属性检查器 中设置这些数值。

这些数值都是建议，一会等游戏运行起来，您完全可以按照自己的喜好随时在 属性检查器 中修改这些数值，不需要改动任何代码，很方
便吧！ 



http://docs.cocos.com/creator/manual/zh/scripting/use-component.html


*** TODO 扩展 Inspector
http://docs.cocos.com/creator/manual/zh/extension/extends-inspector.html

editor can extend user script component's inspector!



*** TODO support hot edit script





*** TODO support worker
add to main worker




*** TODO add to wdb



*** TODO support js


*** TODO support reason?
can add compiler in front end for user to compile reason to js???





*** TODO editor: add script asset




*** TODO optimize


*** TODO future
**** TODO add more attribute type
e.g. asset type...
https://developer.playcanvas.com/en/user-manual/scripting/script-attributes/




**** TODO add online code editor







** TODO demo
*** TODO 3d snake



** TODO publish
*** DONE engine
CLOSED: [2019-05-31 Fri 21:02]

//pass coverage


//pass climate


//pass ci



*** TODO editor
**** DONE fix: wheel not work
CLOSED: [2019-06-01 Sat 06:45]


**** DONE feat: script component->support int
CLOSED: [2019-06-01 Sat 07:29]

**** DONE improve(ui): expand ab select zone
CLOSED: [2019-06-01 Sat 08:00]







*** TODO publish to pre-publish


*** DONE publish to online
CLOSED: [2019-06-02 Sun 09:39]





*** DONE write 1.1 blog
CLOSED: [2019-06-02 Sun 10:54]


*** DONE video
CLOSED: [2019-06-02 Sun 10:54]


分p: 视频列表



add 1.1版本新功能演示 video



*** DONE update roadmap
CLOSED: [2019-06-02 Sun 16:08]


*** DONE website
CLOSED: [2019-06-02 Sun 16:08]
add zhihu link

add blogs to blog





* won't fix


* need reproduce






* 未解决的问题




* 明日计划



* 中期研究


* TODO 未来7日计划

** TODO engine

*** TODO skybox
still need add MeshRenderer:
add skyboxMaterialRenderGameObjectMap;
get the first one of the render array to render;
if render array's length > 1, warn;


**** TODO fix: enable point scale
refer to:
http://www.yulistudio.top/demo/FullPhotoMgr/?nsukey=aDk%2FzSXdrECENsIg0GSycTQEwz3CCzQpCHmrTrvDZQL5VOa3m2IPmzqZj%2Fg3QJrbv%2BdOEkL3MmM1AgDKeV32kKlC4x%2Bn9JuFYZUDX5XTq0%2FR3LXK1FKCdSYsgIRuqergfE8zPDs%2BHM7PfsnYBXp0c4XSyEp2EVtQmrfgXswOUyhKwoVZ8Ndt%2Fvqt%2FrwFMbNcnnlFP5mag7R7IXyvIN9QSQ%3D%3D



**** TODO extract SkyboxMaterial


**** TODO extract SkyboxComponent
add onlyRender api:
set other skybox gameObjects' meshrenderer->isRender to false;
set this one's  meshrenderer->isRender to true;





**** TODO test




**** TODO fix: not require skybox


**** TODO extract cubemap texture

***** TODO optimize switch skybox
switch cubemap texture, each one should only update once



**** TODO pass worker






*** TODO add 2d ui(script api? component?)
line

text

////window

////button




**** TODO optimize(refer to threejs)
use 3d line, text instead of 2d canvas?

refer to:
http://www.yulistudio.top/demo/FullPhotoMgr/?nsukey=aDk%2FzSXdrECENsIg0GSycTQEwz3CCzQpCHmrTrvDZQL5VOa3m2IPmzqZj%2Fg3QJrbv%2BdOEkL3MmM1AgDKeV32kKlC4x%2Bn9JuFYZUDX5XTq0%2FR3LXK1FKCdSYsgIRuqergfE8zPDs%2BHM7PfsnYBXp0c4XSyEp2EVtQmrfgXswOUyhKwoVZ8Ndt%2Fvqt%2FrwFMbNcnnlFP5mag7R7IXyvIN9QSQ%3D%3D
http://taobaofed.org/blog/2016/04/25/performance-composite/
https://juejin.im/entry/59dc9aedf265da43200232f9




**** TODO pass worker



*** TODO extend imgui(or add gameObject based ui???)
**** TODO support set imgui



api add add/remove/set/get/replace/clearIMGUIFunc
(replace = remove + set + add)


editor should set imgui data(load fnt, fnt image, custom images)
(publish->should load imgui data at begin)



**** TODO expand imgui:

fix slider:
change isSelected to isPointDown, isPointUp events!





image add offset data
add buttomImage



add color picker



add textarea




**** TODO pass in mobile



*** TODO handle jiehuo api
e.g. ray, loadImageDataArr



*** TODO add LoadManager for html
should for loading bar




**** TODO engine



**** TODO editor->publish->index.html





*** TODO fix jiehuo(by engine)
use skybox

use 2d ui

use imgui instead of dom



** TODO editor
*** TODO feat: finish engine->wdb,asset bundle





*** TODO add 2d ui(script api? component?)


*** TODO add skybox




*** TODO add imgui




*** TODO run in mobile(publish)
**** TODO feat(publish): for publish local to mobile: add try catch for initSample in html for debug



*** TODO editor enhance
**** TODO support set isRender

**** TODO support set gameObject->isActive

**** TODO support set script->isActive





** TODO engine, editor
*** TODO add debug info
fps, memory, draw count, ...

////show profile in mobile?





** TODO feat: add setting->buffer for user
e.g. :
support load terrain.zip , show wdb inspector



** TODO finish jiehuo demo in editor(run in pc/mobile)
*** TODO use asset bundle



** TODO fix bugs

*** TODO fix: dispose with wdb asset
1.load elf_girl.zip
2.drag to scene
3.dispose it in scene
4.dispose its first material asset: lambert22SG


scene will has it gameObject again!!!!







** TODO publish

*** TODO publish to online
**** TODO add demo document
**** TODO write script api document




** TODO engine
*** TODO add collider

*** TODO add physics

*** TODO add picking



** TODO editor
*** TODO add collider

*** TODO add physics

*** TODO add picking



** TODO engine
*** TODO add articulated animation


** TODO editor
*** TODO add articulated animation





** TODO engine
*** TODO add outline for user(add job?)


** TODO editor
*** TODO add outline for user(add job?)





** TODO finish manager system application(run in pc)
can switch scene(use assetbundle)

can browser by first-person camera(no character)

can't go through wall(collider)

can pick gameObject and show its outline and info(picking, outline, imgui)

use imgui as ui



*** TODO use asset bundle


** TODO finish scene demo(can has animation(transform) by script) in editor(run in pc/mobile)
can jump between scene1 and scene2


1.main ui


2.outer scene
click door to enter inner scene
(add 2d ui(e.g. mark text) to mark door)


3.inner scene
click door to enter outer scene
(add 2d ui(e.g. mark text) to mark door)


*** TODO use asset bundle


** TODO enhance script
*** TODO feat: script attribute add "not show in inspector" config!

*** TODO support hot reload
add swap event function







*** TODO add more


**** TODO add more type
add string


support array


...


**** TODO add more event function




**** TODO add global function/shared data
can get global function/shared data in event functions(in api param?)



**** TODO add more api
script api add more
(e.g. add unsafeFindGeometryByName, ...)












** TODO publish
*** TODO set 百度百科




** TODO write blog
////*** TODO canvas 模拟3d效果
如画线

2d-3d 坐标转换


回答: 如何使用WebGL绘制平面网格线？
https://www.zhihu.com/question/325261675


*** TODO 继续系列博文








** TODO engine


*** TODO add skin animation



*** TODO add gameObject based ui?



*** TODO add sound(webaudio)


////** TODO charge fee
publish,asset bundle


** TODO editor

*** TODO add skin animation


*** TODO add gameObject based ui?

*** TODO add sound(webaudio)




*** TODO publish to weixin


** TODO finish game(run in pc and mobile)
*** TODO use asset bundle






** TODO publish




** TODO support pbr

** TODO add more map
*** TODO add normal map

*** TODO add displace map?

*** TODO add light map

*** TODO add emission map



*** TODO add compressed texture map?


/*
** TODO support blend



** TODO support reflection, refraction, fresnel



** TODO add mirror
*/


** TODO feat(demo): add scene demo which use these render techs
add first-person camera to look



** TODO publish



** TODO add more cameraControllers


** TODO support mobile


** TODO support publish to weixin->small game


** TODO publish




** TODO support publish to host platform



** TODO publish




** TODO optimize
compress geometry:
https://github.com/google/draco

** TODO finish projects to apply engine(beta)
(add needed feature from 0.x engine version!!!)

(
use reason to write some demos, and use js to write some demos

(because user can use both reason or js to write its logic(e.g. in script component))
)



*** TODO mobile


**** TODO Multiresolution adaptation


**** TODO add mobile render pipeline



**** TODO run test 
***** TODO show model





*** TODO game(both in pc and mobile)
**** TODO 3d snake
**** TODO poke a mole 



*** TODO indoor scene(both in pc and mobile)




*** TODO finish a multi-player, game-replay game
refer to:
http://gad.qq.com/article/detail/28682
http://gad.qq.com/article/detail/28219
http://gad.qq.com/article/detail/29595


https://blog.codingnow.com/2016/10/synchronization.html
https://blog.codingnow.com/2016/10/gamesync.html


use ecs to write gameplay logic!!!???


according to game-replay function to understand why system can't invoke each other!!!



according to multi-player function to understand ecs(to handle diferent component/data; restore one or more components)!!!


*** TODO game code should not import not used code
not initData/add init,dispose together?
or game code will not import code except initData?



*** TODO in pc

**** TODO write a rpg game(spirit game)(spirit dream?)(can get resource about 3d engine, meditation, spirit, pi gu, juexing...)
refer to https://github.com/pissang/qtek-bootcamp 

use blender to generate assets


(taiji game? yijing game?)


**** TODO build custom outer scene(octree+lod+direction light+collision+shadowmap+terrain+water(mirror reflection, refraction) + morph animation player character)
***** TODO support physics heightmap
add physics box,sphere
player can collision with these box,sphere







add demo:
refer to babylonjs=>Samples/Scenes/WorldMonger/

refer to http://www.babylonjs-playground.com/#E6OZX#7
add mix map, normal map

layer texture(blend)(use blend map)

water

cloud

sky dome


add tree

add grass

shadow(shadowMap, lightMap)




**** TODO build custom room scene(point light+lightmap+shadowmap+cubemap reflection+articulated camera+collision)





*** TODO in mobile
**** TODO run in mobile
***** TODO rewrite bainian project(use require:cmd/nodejs)
****** TODO fix in mobile
run in mobile environment:
fix skin animation:(first animation is not play completely)
(due to elapsed !== _beginElapsedxxx at the first update!)
refactor and test: save begin time
articulated also has the bug!?


build mobile test environment



fix:
set pixel ratio in mobile => set style width/height?
         view.width = view.width * window.devicePixelRatio;
         view.height = view.height * window.devicePixelRatio;
         view.styleWidth = view.width + "px";
         view.styleHeight = view.height + "px";

set viewport?:
gl && gl.viewport(
    camera.viewPort[0] / window.devicePixelRatio,
    camera.viewPort[1] / window.devicePixelRatio,
    camera.viewPort[2] / window.devicePixelRatio,
    camera.viewPort[3] / window.devicePixelRatio
);



optimize:
hongbao=> parse and assemble geometry is slow
(compress position,joint,weight... to one buffer)





fix:
maoke=>arcball camera=>roll up/down is wrong!

unify Animation,SingleLayerKeyFrameAnimation,MultiLayerKeyFrameAnimation=>play=>params
refactor Animation,SingleLayerKeyFrameAnimation,MultiLayerKeyFrameAnimation=>playOneTime(move to Animation)


optimize:
maoke=>arcball camera=>roll is very slow!




enhance mobile debug:
rewrite console:
http://eclipsesource.com/blogs/2012/08/14/debugging-javascript-on-android-and-ios/
use vconsole:
https://www.qianduan.net/vconsole-open-source/

show profile info



feat: Collider add "setFromVertices"
















optimize:
//solve switch cat slow:
//precompute cat2 bone matrix(update(0)?)


//play sound after show 






















**** TODO mobile optimize
http://www.cnblogs.com/ghl_carmack/p/5401906.html
http://www.cnblogs.com/gameknife/p/3515714.html

https://developers.google.com/speed/docs/insights/mobile


http://blog.csdn.net/leonwei/article/details/79298381

***** refer to hongbao:
optimize:
show other model in later(show bainian animation of another model when click on first model)

optimize:
parse and assemble hilo3d(now parse geometry is very slow)



optimize hongbao in ios(also in android?):
optimize model=>antialias in android,ios




optimize hongbao=>03b => cat(xxxSurface_251(66?))=>normal compute:
isn't correct!


**** TODO optimize asset
refer to hongbao:
optimize skin animation
optimize model geometry


**** TODO tao fu wa
**** TODO simple room scene(player with skin animation to navigator)
**** TODO simple outer scene





*** TODO in both
**** TODO car demo(replace material)
**** TODO physics demo(like tao fu wa)
**** TODO jiao's picture demo(particle, picking, hdr, reflection)


*** TODO fix problems
*** TODO optimize










** TODO support mobile
*** TODO run in mobile?
refer to https://blog.codingnow.com/2017/12/mobile_3d_engine.html :
我一开始就会把引擎的运行时和编辑器设计成 C/S 结构，即编辑器和项目是跑在不同的位置的。开发期间，要求开发者必须把项目运行
在真机上，让移动设备真机变成真正的第二块显示窗口，而不是像 Unity 那样，开发在 PC 上，只在必要的时候打包上传到设备上开发。
这样，开发者自然在整个开发过程中都时刻在关注游戏在真实设备上运行的状况、是否发热严重、帧率是否够、会不会内存不足、操作是
否合理，等等。任何时候，都可以方便快捷的插拔不同的硬件设备做测试，省去繁杂的打包上传流程。 

编辑器和游戏项目基于自定义的简单协议通讯。本质上是在移动设备上运行一个纯引擎的 app ，没有任何资源和业务代码，接管了底层
的 IO 操作，映射到开发机上。当这个 app 运行时读取程序脚本时，其实是通过 usb 或 wifi 读取的开发机上的代码；资源加载亦然。
只需要做好 cache 同步机制，和资源在本地运行几乎没有区别。输入设备也是把开发机的鼠标键盘通过协议映射到移动设备上的，并不
需要在开发的时候去点手机的屏幕。我们还可以为游戏项目实现一些调试功能界面，直接显示放在开发机上，比在手机上做一个调试控制
台，使用起来要舒适的多。 


*** TODO engine
**** TODO 多分辨率适配
http://docs.cocos.com/creator/manual/zh/ui/multi-resolution.html


**** TODO add mobile render pipeline

////** TODO publish alpha.6



*** TODO editor
使用手机扫描二维码，可以立即在手机上预览游戏。


*** TODO application
微信小游戏：
[[http://tech.qq.com/a/20171228/033531.htm][微信宣布小程序增加新类目“小游戏” 已上线《跳一跳》等]]


Facebook Instant Games:
http://gad.qq.com/article/detail/41976
https://zhuanlan.zhihu.com/p/34565801
https://developers.facebook.com/docs/games/instant-games







** TODO optimize render
https://zhuanlan.zhihu.com/p/33865743
https://zhuanlan.zhihu.com/p/33868831
https://interplayoflight.wordpress.com/2017/10/25/how-unreal-renders-a-frame-part-3/


http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study/
http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study-part-2/
http://www.adriancourreges.com/blog/2015/11/02/gta-v-graphics-study-part-3/



** TODO add tag
** TODO blog
完成博文：展示函数式编程（fp)＋面向数据(do)＋组件架构在引擎中的设计，为编辑器架构设计提供参考

** TODO defer+forward render
**** TODO support transparent

support use forward shading to draw transparent objects



** TODO study how to texture by using tool
https://www.youtube.com/watch?v=p4ngVoGIj1Q
https://www.youtube.com/watch?v=LcCQKuWPhXk
https://www.youtube.com/watch?v=u2GAHnDaUpU



uv map:
https://www.youtube.com/watch?v=f2-FfB9kRmE
https://www.youtube.com/watch?v=W-ZmDKuB6HI



texture painting:
https://www.youtube.com/watch?v=Hr_itixx0Yo




** TODO refactor: add defer render pipeline
refer to stingray=>renderer


user can expand pipeline:
render Object?

add render component?:
defer shading render component
forward render component


refactor glsl:
separate defer render, front render, webgl1, webgl2


need user render script?



*** TODO unit test


*** TODO pass render worker



*** TODO unit test




** TODO publish





** TODO use glsl-optimizer
optimize:
wonder-glsl-compiler should read shader_libs.re and generate completely vs,fs source(buildGLSLSouce)



use it to generate optimized glsl code when gl.shaderSource:
http://aras-p.info/blog/2010/09/29/glsl-optimizer/
https://github.com/aras-p/glsl-optimizer








** TODO shadow
use esm instead of vsm?
http://www.klayge.org/2013/10/07/%E5%88%87%E6%8D%A2%E5%88%B0esm/




*** TODO support forward shading shadow

*** TODO support defer shading shadow
优化4：Shadowing pass
KlayGE用shadow map渲染阴影。其生成shadow map的过程和普通方法一样，这里就不累赘了。在使用shadow map的时候有两个选择，以前
的方法是在lighting pass里计算光照的时候就查询shadow map，同时计算阴影。另一个方法来自Screen space shadow map。在每个
lighting pass之前加一个shadowing pass，仅仅查询shadow map和计算阴影本身（结果是个灰度图）。这样的好处是，shadowing可以在
更低的分辨率上计算，而不用和lighting pass用同样的分辨率，提高效率。另外，shadowing pass的结果可以像screen space shadow
map那样做一次blur，在让lighting pass使用。 


https://newq.net/publications/more/s2015-many-lights-course => Part 3: Efficient Shadows from Many Lights



*** TODO pass render worker



*** TODO optimize
https://www.zhihu.com/question/266992189/answer/316708229


**** TODO Shadow Caster Culling
http://blog.csdn.net/bugrunner/article/details/7648647
https://users.aalto.fi/~silvena4/Publications/Shadow_Caster_Culling_for_Efficient_Shadow_Mapping.pdf
https://support.umbra3d.com/hc/en-us/articles/214108565-Optimizing-shadow-mapping-with-Shadow-Caster-Culling
https://support.umbra3d.com/hc/en-us/articles/115003369629-Shadow-Caster-Culling-Explained


***** TODO optimize in engine architecture
http://ourmachinery.com/post/simple-parallel-rendering/






** TODO Wonder.js/wonder-package not post install global packages!
"postinstall": "sudo npm install -g typescript@next && sudo npm install -g rollup && sudo npm install -g typescript-formatter",



** TODO refactor
change Director,GPUDetector to function!

** TODO demo test(in new branch to test)(no unit test,render test)
*** TODO Data driven renderer
rewrite renderer
*** TODO try use webAssembly in engine for cpu compute
**** TODO write a webAssembly demo
use https://github.com/01alchemist/TurboScript to compile js to webAssembly
use webAssembly js api to invoke it in js in demo
*** TODO render rewrite(v)
**** TODO transient Resource System
https://www.slideshare.net/DICEStudio/framegraph-extensible-rendering-architecture-in-frostbite
memory pool for textures



*** TODO refactor
refactor getComponent=>paradigms



add "compilerOptions" to tsconfig.json(add to base tsconfig.json, others extend it)


mateiral add to meshrenderer


use es5,es6=>Object added method to refactor:
use assign instead of extend?

optimize deep clone:
http://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript?rq=1
http://stackoverflow.com/questions/728360/how-do-i-correctly-clone-a-javascript-object?rq=1

use keys in Hash=>getKeys?


upgrade typescript to 2.2

*** TODO loader,asset data driven

refer to https://blog.molecular-matters.com/2013/05/17/adventures-in-data-oriented-design-part-3b-internal-references/:
 you can still make sure that the scripts themselves are contiguous in memory by allocating them with a suitable
 allocator. As an example, I use a linear/stack-based allocator for all resources being loaded, and resources are sorted
 inside their resource bundles. This means that in memory, all script code (also meshes, textures, etc.) will be right
 next to each other, with pointers to scripts stored elsewhere. 




use string id:
http://cowboyprogramming.com/2007/01/04/practical-hash-ids/
http://www.randygaul.net/2015/12/11/preprocessed-strings-for-asset-ids/



** TODO advanced asset load
http://what-when-how.com/Tutorial/topic-4863q9vm8/HTML5-Game-Development-Insights-20.html

http://what-when-how.com/Tutorial/topic-4863q9vm8/HTML5-Game-Development-Insights-333.html


*** TODO support stream load?
https://github.com/AVGP/streaming-webgl-demo
https://github.com/whatwg/streams
https://streams.spec.whatwg.org/


*** TODO support scene stream load
Scene streaming management:
Easily create vast worlds by streaming objects in and out of your scenes. Divide your world into subscenes to avoid
editing conflicts. 

https://stackoverflow.com/questions/25823729/large-3d-scene-streaming
https://forum.unity.com/threads/released-sectr-stream-seamless-scene-streaming.229907/


** TODO continue rewrite(keep engine size min)(1.0.0-alpha.xxx)
*** TODO use Data-Driven Design?





Applications in Games
• Particles, Soft-body, Rigid-body, Fluid Simulation
• Collision, Visibility Detection
• Skeletal Animation



• Group Behavior Simulation

http://twvideo01.ubm-us.net/o1/vault/gdcchina14/presentations/833779_MiloYip_ADataOriented_EN.pdf

http://www.slideshare.net/DICEStudio/culling-the-battlefield-data-oriented-design-in-practice



Think about data first, and code second. Class hierarchies aren’t important, but data access patterns are.
Think about how data in your game is accessed, how it is transformed, and what you end up doing with it, e.g. particles, skinned characters, rigid bodies, and tons of other examples.
When there’s one, there’s many. Think in streams of data.
Be aware of the overhead of virtual functions, pointers to functions, and pointers to member functions.



study "virtual function"




**** TODO unity
https://forum.unity3d.com/threads/data-oriented-designed-game-in-unity.350118/

what's Unity DOES?
Unity DOES use DOD, in the places where it eeks out large benefits.

Mesh data and texture data just makes more sense that way. 
*** TODO support multi-thread(maybe need rewrite runtime)
js multi thread:
https://blog.mozilla.org/javascript/2015/02/26/the-path-to-parallel-javascript/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SharedArrayBuffer

simd
https://blog.mozilla.org/javascript/2015/03/10/state-of-simd-js-performance-in-firefox/

extract multi thread object/component?


**** TODO multi-thread render
http://www.cnblogs.com/ixnehc/archive/2008/09/04/1284708.html
http://www.bennychen.cn/2011/01/%E5%85%B3%E4%BA%8E%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%80%E4%BA%9B%E6%95%B4%E7%90%86%E5%92%8C%E6%80%9D%E8%80%83/
http://www.cppblog.com/flagship/archive/2009/03/25/77886.html

unity:
https://blogs.unity3d.com/cn/2015/02/06/extending-unity-5-rendering-pipeline-command-buffers/
https://docs.google.com/document/d/1e2jkr_-v5iaZRuHdnMrSv978LuJKYZhsIYnrDkNAuvQ/edit
https://github.com/Unity-Technologies/ScriptableRenderLoop
**** TODO multi-thread load asset



support load multi part of one model?
(refer to http://www.inka3d.com/)
**** TODO multi-thread collision(refer to babylonjs=>worker)
*** TODO rewrite render loop(refer to unity)
**** TODO refactor?
refactor: move material to renderer?


add billboard/line renderer?

add skin mesh renderer?
https://docs.unity3d.com/Manual/class-SkinnedMeshRenderer.html

**** TODO support command buffer
https://docs.unity3d.com/Manual/GraphicsCommandBuffers.html
https://docs.unity3d.com/ScriptReference/Rendering.CommandBuffer.html


add more render command(e.g., set render target, ...)

**** TODO support Scriptable Render Loops
https://docs.google.com/document/d/1e2jkr_-v5iaZRuHdnMrSv978LuJKYZhsIYnrDkNAuvQ/edit#
https://github.com/Unity-Technologies/ScriptableRenderLoop

TL;DR
Motivation
Need to perform better on modern hardware
Easier to customize & extend, less “black box”
Easier dealing with backwards compatibility
Scriptable Render Loops: the new foundation
API Overview
Usage, inner workings, performance
New built-in “HD Render Loop”
Lighting Features
Material Features
Camera Features
Workflow / Debug Features
Appendix - Current Rendering Pipeline in Unity
Shadows
Forward Rendering
Deferred Shading
Customization
TL;DR
Reimagine the rendering pipeline to support more flexibility and transparency. The main Unity rendering pipeline will be replaced by multiple "Render Loops", built in C# on a C++ foundation. The C# code for the "Render Loops" will be open-sourced on GitHub, enabling users to investigate, enhance, or create their own custom render loops.
Motivation
Current Unity’s rendering pipeline is described in Appendix - Current Rendering Pipeline. There are several improvements we want to make -- the major ones are spelled below.
Need to perform better on modern hardware
Both “one light per draw call” forward rendering, and “stencil mark + draw shape per light” deferred shading are not exactly modern approaches -- they were fine for roughly DX9 hardware, but with advent of compute shaders generally we can do much better. Our forward shading suffers from too many draw calls (CPU + vertex transform cost) and bandwidth consumed by repeated sampling of surface textures & blending; whereas deferred shading suffers from draw call count, not enough light culling, cost of doing stencil mark + draw call per light and repeated fetching of G-buffer data. Additionally, on tile-based GPUs it does tile store+load too much when realtime shadows are involved, and does not take advantage of tile storage or framebuffer fetch.
We’d like to ship Unity with an out-of-the box rendering pipeline that is targeted at modern hardware -- where we can rely on API & GPU features like compute shaders, draw call instancing, constant buffers etc.
Easier to customize & extend, less “black box”
Most of Unity users would probably not modify the built-in rendering pipeline, but some of the more advanced teams do want to modify or extend it. So it has to be extensible and much less opaque than today.
While the current rendering pipeline is somewhat extensible (users can write their own shaders, manually control camera rendering, change settings, extend the rendering pipeline with command buffers), it is not extensible enough. Additionally, it is too much of a “black box”, and while the documentation, conference presentations, MIT-licensed built-in shader source code and community knowledge does fill in the gaps, some parts are hard to understand without a Unity source code license. We want all the high level code and shader/compute code to be a MIT-licensed open source project, similar to how Post-Processing, UI or Networking already are.
A “single render pipeline for everything” likely has some compromises that make it more flexible at expense of performance. We imagine that, for example, these kinds of rendering pipelines would make sense in many cases:
Optimized for modern PC/console (DX11 baseline, “high end” graphics).
Optimized for on-tile storage of mobile GPUs, using framebuffer fetch or other available techniques.
Optimized for VR (e.g. forward shading + MSAA, single-pass rendering, caching/sharing eye rendering results in distance, various schemes of viewport/resolution stitching).
Optimized for low-end devices (old mobile, old PC) or simple 2D games: simple one pass lighting (limited # of lights, and/or vertex lighting).
These don’t have to be physically separate rendering pipelines, could be options in some other existing pipelines.
Easier dealing with backwards compatibility
This is a hard problem for us at Unity R&D, basically doing big changes to how the rendering engine works is quite hard -- mostly because people do expect to update to a more recent Unity version and have things “still working as they did”. Except when they don’t, i.e. they actively want new changes... For example, we changed Standard shader from Blinn-Phong to GGX specular in Unity 5.3 -- mostly this is a good thing, except for people who were mid-production and now their specular behaves differently (so they probably have to re-tweak their lighting setups and materials).
We’re thinking, that if the high level structure of the rendering code, and all the shader code, was easily “forkable” and versionable, then this problem could become easier.

Scriptable Render Loops: the new foundation
We think all or most of the problems listed above can be solved fairly elegantly by having a solid, orthogonal, performant foundation to build upon, which would basically be “an ability to render sets of objects with various filtering criteria efficiently”. The division of work would be:
Unity C++ code
C#/shader code (MIT open source)
Culling
Render set of objects with filter/sort/params
Internal graphics platform abstraction
Camera setup
Light setup
Shadows setup
Frame render pass structure & logic
Shader/compute code

The C++ side would be mostly not even aware that things like “Camera” or “Light” exist; e.g. culling code gets arrays of bounding primitives and matrices / culling planes as input. It does not care whether it’s culling main view, reflection rendering view or a shadow map view.
Likewise, rendering code is expressed in terms of “from the culling results, render everything that is within opaque render queues range, has this shader pass and does not have that shader pass, sort by material then by distance, setup light probe constants per-object”. There is some amount of conventions and built-in things in there, mostly in what kind of data should be set as per-instance data for each object (light probes, reflection probes, lightmaps, per-object light lists etc.).
There’s a lot of underlying platform graphics abstraction changes that we’re doing in order to be able to provide a robust, high performance and orthogonal set of “building blocks” to build scriptable render loops upon, but they are mostly outside of the scope of this document. Some of the changes worked on are:
Expose “Buffer” as a C# class, that would be used for all kinds of buffer data (vertices, indices, uniforms, compute data etc.). Ability to create and manually update uniform/constant buffers from C# side.
Compute shader related improvements, particularly how data is passed to them.
Remove split between TextureFormat and RenderTextureFormat, have something like “DataFormat” instead that is used in all graphics related code (similar to DXGI formats on D3D). Expose more formats than today.
Asynchronous readbacks of GPU data. Asynchronous compute.

API Overview
Note: the API is in flux, and this document might not be exact wrt whatever Unity version you’re testing with right now.
The main entry point is RenderLoop.renderLoopDelegate, which is in a form of
bool PrepareRenderLoop(Camera[] cameras, RenderLoop outputLoop);
When the render loop delegate is registered, then all rendering goes into that function, and the existing built-in rendering loops are not executed at all.
Inside of the render loop delegate, typically it would do culling for all the cameras (via the new CullResults class), and then do series of calls to RenderLoop.DrawRenderers intermixed with CommandBuffer calls to setup global shader properties, change render targets, dispatch compute shaders etc.
Overall, the design is that the C# render loop code has full control over per-camera logic (it gets all cameras as input), and all per-light logic (it gets all visible lights as a culling result), but generally does not do per-object logic. Objects are rendered in “sets” -- DrawRenderers call that specifies which subset of visible objects to render, how to sort them, and what kind of per-object data to setup.
The simplest possible render loop would look something like this:
public bool Render(Camera[] cameras, RenderLoop renderLoop)
{
  foreach (var camera in cameras)
  {
      // cull a camera
      CullResults cull;
      CullingParameters cullingParams;
      if (!CullResults.GetCullingParameters (camera, out cullingParams))
          continue;
      cull = CullResults.Cull (ref cullingParams, renderLoop);
      renderLoop.SetupCameraProperties (camera);

      // setup render target and clear it
      var cmd = new CommandBuffer();
      cmd.SetRenderTarget(BuiltinRenderTextureType.CameraTarget);
      cmd.ClearRenderTarget(true, true, Color.black);
      renderLoop.ExecuteCommandBuffer(cmd);
      cmd.Dispose();

      // draw all the opaque objects using ForwardBase shader pass
      var settings = new DrawRendererSettings(cull, camera, "ForwardBase");
      settings.sorting.sortOptions = SortOptions.SortByMaterialThenMesh;
      settings.inputFilter.SetQueuesOpaque();
      renderLoop.DrawRenderers(ref settings);

      renderLoop.Submit ();
  }
  return true;
}


Most important new scripting APIs:
// main entry point
struct RenderLoop
{
void ExecuteCommandBuffer (CommandBuffer);
void DrawRenderers (ref DrawRendererSettings);
void DrawShadows (ref DrawShadowsSettings); // similar, slightly specialized
void DrawSkybox (Camera);
static PrepareRenderLoop renderLoopDelegate;
}

// Setup and control how sets of objects are rendered by RenderLoop.DrawRenderers
struct DrawRendererSettings
{
DrawRendererSortSettings sorting;
ShaderPassName shaderPassName;
InputFilter inputFilter;
RendererConfiguration rendererConfiguration;
CullResults cullResults { set };
}

struct DrawRendererSortSettings
{
Matrix4x4 worldToCameraMatrix;
Vector3 cameraPosition;
SortOptions sortOptions;
bool sortOrthographic;
}

enum SortOptions { None, FrontToBack, BackToFront, SortByMaterialThenMesh, ... };

struct InputFilter
{
int renderQueueMin, renderQueueMax;
int layerMask;
};

// what kind of data should be set up per-object when rendering them
[Flags] enum RendererConfiguration
{
None,
PerObjectLightProbe,
PerObjectReflectionProbes,
PerObjectLightProbeProxyVolume,
PerObjectLightmaps,
ProvideLightIndices,
// ...
};

// Culling and cull results
struct CullResults
{
VisibleLight[] visibleLights;
VisibleReflectionProbe[] visibleReflectionProbes;
bool GetCullingParameters(Camera, out CulingParameters);
static CullResults Cull(ref CullingParameters, RenderLoop renderLoop);
// utility functions, like
// ComputeDirectionalShadowMatricesAndCullingPrimitives etc
}


struct CullingParameters
{
int isOrthographic;
LODParameters lodParameters;
Plane cullingPlanes[10];
int cullingPlaneCount;
int cullingMask;
float layerCullDistances[32];
Matrix4x4 cullingMatrix;
Vector3 position;
float shadowDistance;
ReflectionProbeSortOptions reflectionProbeSortOptions;
Camera camera;
}

struct VisibleLight
{
LightType lightType;
Color finalColor;
Rect screenRect;
Matrix4x4 localToWorld;
Matrix4x4 worldToLocal;
float range;
float invCosHalfSpotAngle;
VisibleLightFlags flags;
Light light { get }
}

struct VisibleReflectionProbe; // similar to VisibleLight…

The API outlined above is very much not final! Things that are very likely to change:
Considering an option to not have RenderLoop class, but instead have CommandBuffer contain functions like DrawRenderers etc., and possibly have nested command buffers too.
Culling API changes to enable more performance, i.e. jobified culling overlapping with other work.
Possibly more renderer filtering options.
More explicit “render pass” controls, instead of current “set render target” API.
Usage, inner workings, performance
The general flow is that your own render loop code is responsible for culling, and for rendering everything. Including setting up per-frame or per-renderpass shader uniform variables, managing temporary render targets and setting them up, dispatching compute shaders etc.
Visible lights and probes can be queried from the cull results, and for example their information put into compute shader buffers for tiled light culling. Alternatively, the render loop provides several ways of setting up per-object light lists for DX9-style forward rendering.
On the CPU performance side, the API is built in a way where there’s generally no per-object operations going on -- the C# side of the code is independent of the scene complexity. It typically loops over cameras, and does some iteration over visible lights to either render shadows, or to pack light data for shader usage. The rest of code that is written in C# is setting up render passes / render textures, and issuing “draw this subset of visible objects” commands.
The C++ part of code (culling, DrawRenderers, DrawShadows) is written in a high-performance style that generally just goes over tightly packed data arrays, and is internally multithreaded. Our current experiments show that with this split (high level frame setup in C#, culling/rendering in C++) we can get same or even better performance of our previous rendering loop implementations.
The C# side looks like it would create a lot of garbage-collected objects; we are looking into ways of exposing “native” (C++ side) data directly to C# without extra round-trips; in C# that would look very similar to an array that writes directly into native side memory. This is a somewhat separate topic, which we’ll talk about separately.

New built-in “HD Render Loop”
We plan to provide a built-in “HD Render Loop” targeted at modern (compute-capable) platforms. Currently it is developed with PC and PS4/XB1 consoles in mind, but we’ll be looking at optimizing it for high-end mobile platforms too. Of particular interest for mobile is optimizing it for on-tile storage / framebuffer fetch and other bandwidth-saving techniques.
Internally, shaders are written in a way that is less reliant on separate shader variants for every imaginable knob, and more using “static” (uniform based) branching, with shader variant specializations only used where that makes sense based on shader analysis / profiling on modern GPUs.
The new HDRenderLoop is being developed at github ScriptableRenderLoop (might be messy at any point, only use if you’re super-curious right now).
Lighting Features
Tiled light culling with compute shaders:
Fine pruned tiled lighting (FPTL) for deferred shaded opaque objects.
Clustered tiled lighting for forward-rendered objects and transparencies.
Rendering can be switched between deferred and forward, depending on what is better for the project.
Lights:
Usual punctual (point/spot) and directional lights.
Area lights (polygonal lights and line lights).
Correct linear lighting & PBR.
Physical light units, IES lights.
(Later) Frustum lights (i.e. bounded directional light).
Shadows:
All realtime shadows are suballocated from a single atlas.
Intuitive controls over shadow memory budget and per-light resolution overrides.
Better PCF filtering, particularly for spot/point lights.
Shadows on semitransparent objects.
GI:
Correct HDR.
Consistency with direct illumination.
(Later) Improved Shadows
Exponential shadow maps (ESM/EVSM).
Improved shadows for area lights.
(Later) Volumetric Lighting
Sky/fog atmospheric scattering model.
Local fog.
Material Features
GGX with Metal & Specular parametrizations, similar to current Standard shader.
Anisotropic GGX (Metal parametrization)
Sub-surface scattering & transmission
Clear coat
Double sided support
Good specular occlusion
Layered materials (mix & mask inputs of other materials, with up to 4 layers)
Heightmaps either via parallax or displacement tessellation
(later) Built-in LOD cross-fade / dithering
(later) Hair, Eye, Cloth shading models
Camera Features
Physically based camera parameters
Support for Unity’s PostProcessing stack
Distortion
Velocity buffer (for motion blur / temporal AA)
(later) Half/quarter resolution rendering (e.g. for particles) and compositing.
Workflow / Debug Features
Views of shader inputs (albedo, normals etc.)
Views of all intermediate buffers of rendering (lighting, motion vectors etc.)
Debug menu to control rendering of various passes

Appendix - Current Rendering Pipeline in Unity
Currently (Unity 5.5 and earlier) Unity supports two rendering pipelines for scene (forward rendering and deferred shading), and one way to render realtime shadows. Following is the description of the current pipeline in more detail:
Shadows
Shadowing system mostly works the same no matter whether the forward or deferred shading is used.
Each realtime light with shadows enabled gets a separate shadow map.
Shadow maps are traditional depth texture maps, in shaders sampled with PCF filtering (no VSM/EVSM etc. shadows).
Directional lights can use cascaded shadow maps (2 or 4 cascades); the shadow map space is divided into cascades like in an atlas.
Spot lights always use simple 2D shadowmap; point lights use a cubemap.
Shadowmap size is computed based on quality settings, screen resolution and light’s projection size on screen; or can be controlled by game developer explicitly from scripts per-light.
Cascaded shadow maps are applied in “screen space” -- there’s a separate “gather and do PCF filtering” step that produces screenspace shadow mask texture; later on regular object rendering just does one sample into this texture.
No support for receiving shadows onto semitransparent objects.
Forward Rendering
The default mode of operation is largely DX9-style “one draw call per light with additive blending”. Quality settings of the game determine how many lights per-object will be rendered in realtime; the rest are folded into a spherical harmonics (SH) representation and rendered together with other ambient lighting.
Optionally before main scene rendering: a “depth texture” rendering pass. This kicks in if scripts require it, or other features (e.g. realtime cascaded shadows) need it. Conceptually this is similar to Z-prepass; produces a texture with scene depth buffer.
Optionally before main scene rendering: a “motion vectors” rendering pass. This kicks in if scripts (e.g. motion blur or temporal AA) require it. Renders a texture of velocity vectors for objects that need them.
Realtime shadow maps are rendered before main scene rendering; all shadows are in memory at once.
Actual scene rendering pass specialized in two shader sets: “ForwardBase” (ambient/probes + lightmaps + lighting/shadows from main directional light), followed by additive blending “ForwardAdd”, that does realtime lighting one light at a time.
Deferred Shading
This is “traditional” DX9-style deferred shading: G-buffer rendering pass, followed by “render light shapes one by one” pass where each of them reads G-buffer data, computes illumination and adds it into lighting buffer.
Similar to forward rendering, an optional motion vectors pass before the G-buffer.
Reflection probes are rendered one by one similar to lights, by rendering box shapes and adding reflections into a texture.
Lights are rendered one by one, by rendering light shapes (fullscreen quad or sphere or cone) and adding reflections into a texture.
Shadow map for a light is rendered just before rendering each light, and generally discarded right after done with it.
Stencil marking is used for both lights and reflection probes to limit the amount of pixels actually computed.
Objects that don’t support deferred shading, and all semitransparent objects, are rendered using forward rendering.
Customization
It is possible to customize the above behavior to some extent, but not much. For example, Valve’s The Lab Renderer (on Asset Store) replaces the built-in behavior by (purely in C# + shaders):
Implementing a custom shadows system, where all shadows are packed into one atlas.
Custom forward rendering system, where all lights are rendered in one pass; light information is setup into custom shader uniform variables.
**** TODO support render component?(refer to Scriptable Render Loop design!)
(upgrade render command to render component?)
so now has two type component:
logic component
render component


regard different render loop as different render object
(mobile,webgl1 pc,webgl2 pc)
(forward render, defer render)

so now has two type object:
logic object
render object




so now has two type script component user can control:
logic script component
render script component(replace command buffer design?)



move buffer,bufferContainer logic to component?
(e.g. so can move animation,shadow logic all to component?)
or buffer,bufferContainer can be extensible by user?


solve:
communication between:
logic object and render object
logic component and render component


*** TODO add unit test

*** TODO study how to separete low-level(optimized) and high-level(extensible) parts
refer to unity:
low-level:c++   high performance, multi thread
high-level:c#   extensible

*** TODO study script(integrate with engine?)
*** TODO build simple world editor(v)



*** TODO add cpu particle system(v)
*** TODO add hdr post effect(v)(move to extension)
**** TODO design
refer to unity post process stack:
https://forum.unity3d.com/threads/new-post-processing-stack-pre-release.435581/
https://github.com/Unity-Technologies/PostProcessing/wiki
https://www.reddit.com/r/Unity3D/comments/56r2h6/unity_technologies_postprocessing_stack_image/

refer to babylonjs

*** TODO support webp image format
https://isux.tencent.com/introduction-of-webp.html


** TODO fix bug(refer to mine/Wonder.js=>commits)
//UIRenderer support set canvas size(left,top,width,height)


//fix OBJ converter=>ObjectsConverter:
refer to threejs=>OBJMTLLoader.js
use 0419.obj model
(children should be 448, but mine is 300+!)
(the g group is wrong! maybe all should rewrite!)



//model info

//model color

optimize picking:
compute center point, closest to camera

////show house:
double side?

use basic material?


//flag a,b,c


need add mesh collider

** TODO update .gltf(.wd) to 2.0

** TODO advanced multi-thread
*** TODO multi thread logic
**** TODO add action
**** TODO add collision

*** TODO SIMD



*** TODO task system
main threads(update thread, render thread)
worker threads:worker_thread_count = number_of_cores - main_thread_count


work items



sub task?


task manager

one depend?

priority



open list(not completed job) + need perform list

**** TODO optimize create render command
preallocate 10000 render commands in array

multi thread create render command

**** TODO define render data in config file

*** TODO thread pool
http://www.smartjava.org/content/html5-easily-parallelize-jobs-using-web-workers-and-threadpool
http://stackoverflow.com/questions/13574158/number-of-web-workers-limit
** TODO use optimize-js to package
https://github.com/nolanlawson/optimize-js


////***** TODO add package unit tests
** TODO optimize shaders
https://www.zhihu.com/question/22595954/answer/61277904
study:
tag math+visibility组件
shader cache收集系统


Windows performance toolkit




only iterate shader lib once



看来是根据序号得到顶点变量名
这个处理的好，这样通过查询来获得变量名，就不要先保存这些变量名了:
refer to three:
function fetchAttributeLocations( gl, program, identifiers ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}


function WebGLUniforms( gl, program, renderer ) {

	UniformContainer.call( this );

	this.renderer = renderer;

	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( var i = 0; i < n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			path = info.name,
			addr = gl.getUniformLocation( program, path );

		parseUniform( info, addr, this );

	}

}





** TODO fbx support morph anim

*** TODO pass skin + morph(use blender)

*** TODO publish




** TODO finish phone=>todo
*** TODO use compress texture?

support .pvr in ios

**** TODO use blender to generate compress texture

*** TODO audio add more control(play one time, stop...)


*** TODO publish 
** TODO optimize(beta)
*** TODO read references
https://developer.nvidia.com/nvidia-gpu-programming-guide

http://www.cnblogs.com/ghl_carmack/p/4107042.html


*** TODO cpu optimize
optimize clone,extend,deepextend:
https://cnodejs.org/topic/56c49662db16d3343df34b13
use Object.assign()
https://github.com/Microsoft/TypeScript/issues/3429
( typescript2.2=>extend)
https://github.com/Microsoft/TypeScript/pull/13604






optimize transform:
optimize Transform=>state?

check is the same in setting position,scale,rotation, localXXX(new value === old value, not set,dirty?)



optimize shader:
staticly compile shader param of libs to one large collection of the one entityObject
(so no need to iterate the shader libs at runtime)


*** TODO memory optimize
add global Temp class, for save temp matrix,vector...
(refer to bjs=>math.ts=>Temp class)

use memory pool instead of Temp class?
(refer to sk_design=>MemoryUtil,MemoryPool)



show memory info:
refer to sk_design=>WebGLRenderer=>dump method


optimize Vector2/3/4:
remove "values" attr


optimize hash=>removeChild



memory optimize:
https://www.scirra.com/blog/76/how-to-write-low-garbage-real-time-javascript
http://blog.tojicode.com/2012/03/javascript-memory-optimization-and.html

http://www.cocos2d-x.org/wiki/How_to_Optimise_Memory_Usage
http://www.cocos2d-x.org/wiki/Memory_Management_of_JSB

http://stackoverflow.com/questions/13914959/three-js-memory-management


http://www.html5gamedevs.com/topic/6903-memory-consumption-difference-between-111-and-112-beta/




use instance pool to re-use render commands

*** TODO specific optimize
**** TODO octree optimize
**** TODO instance optimize
////**** TODO shadow optimize


** TODO optimize cpu(v0.5.8)
//render target renderer(e.g. Mirror,Refraction,DynamicCubemap, ...) and procedural renderer, shadowMap(refer to
babylonjs=>Samples/Demos/Instances/instances.js line 100), VideoTexture,   add "refreshRate", "refresh control"(like
stop refresh,start refresh, refresh(count):refresh the specify times
(Math.ceil, 1=>refresh every frame; 2=>refresh every 2 frames;0=>refresh only in the first frame, ...)
(add refresh rate counter)





use texture matrix to replace repeat,part data



move BoxGeometry, ...(except ModelGeometry,CustomGeometry) computation
to worker
(refer to <<webgl insights>> p81)





optimize math library(e.g., Matrix4,Matrix3...):
use TDL, Closure, and gl-matrix instead? or modify the existed library
based on them?

From the benchmark it is clear that TDL, Closure, and gl-matrix are
the top contenders in terms of performance as tested on a MacBook Pro
(OS X 10.9.5, 2.4 GHz Intel Core i7, 8 GB 1333 MHz DDR3).  





//data orient driven(refer to game engine germ 1/2)



regard octree,lod as benchmark test



https://blogs.msdn.microsoft.com/eternalcoding/2013/05/21/benchmarking-a-html5-game-html5-potatoes-gaming-bench/
https://blogs.msdn.microsoft.com/eternalcoding/2015/01/07/javascript-shoud-i-have-to-cache-my-arrays-length/
https://blogs.msdn.microsoft.com/eternalcoding/2015/02/02/using-user-mark-to-analyze-performance-of-your-javascript-code/




https://www.smashingmagazine.com/2012/11/writing-fast-memory-efficient-javascript/
https://msdn.microsoft.com/en-us/library/windows/apps/hh781219.aspx
https://channel9.msdn.com/Events/Build/2013/4-313
http://malideveloper.arm.com/downloads/GDC14/Thursday/10.30amWebGL.pdf




use webgl-inspector=>highlights to see duplicate setting uniforms

Note that uniforms are specific to programs and they are remembered by the programs, so you don't have to re-set them
every time you switch programs! 




not create duplicate textures







BufferContainer=>getChild=>apply:
remove @cache
use {} instead of Hash



optimize ArticulateAnimation=>_updateTargets





ActionManager=>update
script=>update





optimize benchmark_shadow test:
optimize memory
camera vpMatrix add cache






optimize instance with octree,lod

optimize:
show 10000 spheres with 60fps(instance)
show 20000 spheres with 60fps(instance + lod)
show 40000 spheres with 60fps(instance + octree)
show 60000 spheres with 60fps(instance + octree + lod)

////only render visable instance

////if not support instance, optimize ethier
(refer to bjs(babylonjs))

////*** TODO optimize: cache all uniform/attribute position when init(then look up the cache table to get the position when send glsl data)
////refer to babylonjs=>effect.ts, engine.ts=>getUniforms/getAttributes method








support merge instancing?
http://www.humus.name/Articles/Persson_GraphicsGemsForGames.pdf
http://hacksoflife.blogspot.com/2013/01/instancing-for-bricksmith.html

When reducing the number of draw calls there are two standard approaches. Multiple
instances of a single mesh is typically done with regular instancing. If there are multiple
meshes, but a single instance of each, they can be merged into a single vertex and index
buffer and drawn with a single draw call. However, sometimes you want to draw multiple
meshes, with multiple instances of each, and each with their own transforms or other instance
data. With instancing this results in multiple draw calls. With the standard merging approach
you need to duplicate the vertex data.
We came up with an approach that combine the benefits of merging and instancing such that
you can draw it all with a single draw call without duplicating vertex data. Thus, for the lack of a
better name, it can be referred to as Merge-Instancing.














optimize octree sample: frustum(especially arcball camera), ray picking, collision

bug:
if add/remove EntityObject, will the octree rebuild?




optimize water,terrain



optimize mirrorMirror, dynamicCubemapTexture




optimize lod

reduce composite layers time(when move camera to switch geometry in lod sample):
http://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome
http://www.html5rocks.com/en/tutorials/speed/scrolling/
https://developer.chrome.com/devtools/docs/timeline
http://www.html5rocks.com/zh/tutorials/speed/layers/



optimize collision:
add layers:
http://docs.unity3d.com/Manual/LayerBasedCollision.html








optimize shadow(especially point shadow)
bug: 
in collision_box sample, why shadow break when move box down to near the edge of screen?(not caused by light=>shadowCameraXXX)

test light move



not bind color to frame when build shadow map?

not bind and send uniform when build shadow map





optimize:
cache camera=>vpMatrix
shadow layer

////not bind texture when build shadow map










*** TODO other

//if the texture is the same there is NO rebinding:

https://github.com/BabylonJS/Babylon.js/blob/master/Babylon/babylon.engine.ts#L1961



//move "create program" logic out of shader?



**** TODO optimize refer to <<OpenGL Insights>>  39 chapter

Group objects in buffers based on data format (type and layout) and update
frequency.

Ensure that appropriate buffer usage flags are used.

Use static buffers and fully specify the contents of buffers before draw time.


Use immutable textures when available?
If EXT texture storage is not supported, ensure that a complete texture is
created and consistently defined. 


Avoid redefining the format or size of existing textures, and create a new tex- ture instead. 


Use packed depth-stencil for combined depth and stencil support.

Avoid masked clear operations.

Avoid using complex conditional statements and loops with a high maximum number of iterations in shaders. 



**** TODO z prepass

not bind and send uniform when z prepass
(bindless or uniform blocks are ways of minimizing these)






***** TODO WebGLRenderer: sort opaque objects from front to end

On IMR GPUs, this extra bandwidth consumption and fragment work can be limited by sorting and rendering geometry from
front to back (see Figure 24.4).  

An additional heuristic for games is to render the player character first and the sky-box last  









**** TODO update profiling tool
refer to <<OpenGL Insights>> 36 chapter

Intel Graphics Performance Analyzers (GPA):(can use only in windows?)
http://www.intel.com/software/gpa

WebGL Inspector shows the WebGL side, and Frame Analyzer shows the post-translation DirectX equivalent 

start Intel Graphics Performance Analyzers:
Fortunately, starting Chrome with a --no-sandbox flag allows GPA to at- tach to the correct rendering process and
trigger frame captures.  





use [[https://software.intel.com/en-us/gpa/details][Graphics Performance Analyzers]] ?


**** TODO use Map/Set to update Hash/Collection



** TODO advanced terrain
https://zhuanlan.zhihu.com/p/33887115



** TODO optimize memory, cg(v0.5.9)




vertex compress
https://cesiumjs.org/2015/05/18/Vertex-Compression/
compress billboard instance data:
https://cesiumjs.org/2015/10/28/Billboard-Instancing/





optimize benchmark_2000_boxes_forRunTest(add action component)




This kind of unwanted memory churn is usually created by algorithms
that compute intermediate values that are quickly thrown away. 

Listing 4.7 A memory-inefficient linear interpolation function.
Cartesian3.add = function(left, right) { var x = left.x + right.x;
var y = left.y + right.y;
var z = left.z + right.z;
return new Cartesian3(x, y, z); };
Cartesian3.multiplyByScalar = function(value, scalar) {
var x = value.x * scalar;
var y = value.y * scalar;
var z = value.z * scalar;
return new Cartesian3(x, y, z); };
Cartesian3.lerp = function(start, end, t) {
var tmp = Cartesian3.multiplyByScalar(end, t);
var tmp2 = Cartesian3.multiplyByScalar(start, 1.0 - t); return Cartesian3.add(tmp, tmp2);
};


Every call to lerp allocates three objects: two intermediate
Cartesian3 instances and the result instance. While a microbenchmark
of 100,000 calls takes about 9.0 milliseconds in Firefox, it doesn’t
expose a problem with garbage collection because the memory is not
cleaned up until after our benchmark has already completed. 
We can remove the extra memory allocation by using two simple
techniques. First, we require users to pass in an already allocated
result parameter to avoid having to create a new instance every
time. Second, we use module-scoped scratch parameters in calls to add
within lerp. 

Listing 4.8 Memory-efficient linear interpolation using result parameters and scratch variables.
Cartesian3.add = function(left, right, result) {
 result.x = left.x + right.x;
result.y = left.y + right.y;
result.z = left.z + right.z;
return result; };
Cartesian3.multiplyByScalar = function(value, scalar) {
 result.x = value.x * scalar;
result.y = value.y * scalar;
result.z = value.z * scalar;
return result; };
var tmp = new Cartesian3(0, 0, 0); var tmp2 = new Cartesian3(0, 0, 0);
Cartesian3.lerp = function(start, end, t, result) { Cartesian3.multiplyByScalar(end, t, tmp); Cartesian3.multiplyByScalar(start, 1.0 - t, tmp2); return Cartesian3.add(tmp, tmp2, result);
};




clean memory
http://stackoverflow.com/questions/23598471/how-do-i-clean-up-and-unload-a-webgl-canvas-context-from-gpu-after-use





For performance, avoid object allocation in the render loop. Reuse objects and arrays where possible, and avoid built-in
array methods such as map and filter. Each new object creates more work for the Garbage Collector, and in some cases, GC
pauses can freeze an application for multiple frames every few seconds. 






release when need:
manage ProgramTable,BufferTable:
add references count
check references to decide whether to dispose the one whose referencs is 0


https://blogs.msdn.microsoft.com/eternalcoding/2013/09/04/reducing-the-pressure-on-the-garbage-collector-by-using-the-f12-developer-bar-of-internet-explorer-11/


http://goocreate.com/learn/reducing-memory-usage/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management
http://www.html5rocks.com/en/tutorials/speed/static-mem-pools/


use Array instead of Collection in the key path?

memory allocate
http://www.mystengine.com/blog/?p=59
http://www.cnblogs.com/dreams/archive/2007/03/25/687310.html





** TODO optimize gpu

*** TODO optimize glsl
https://www.opengl.org/wiki/GLSL_Optimizations


[[http://aras-p.info/blog/2011/08/17/fast-mobile-shaders-or-i-did-a-talk-at-siggraph/][Fast Mobile Shaders]]


When we suspect that our application is shader-bound, we can always
perform a simple test to see if this really is the case: Replace all
of the shaders with trivial ones that only render a single
recognizable color and measure the performance. If the performance is
significantly changed, the application is likely shader-bound—either
by GPU computa- tion or by texture fetches performed by the shaders. 




*** TODO other

http://malideveloper.arm.com/downloads/GDC14/Thursday/10.30amWebGL.pdf



////** TODO optimize: batch draw calls(v0.5.10)
use stride in gl.vertexAttribPointer(refer to Wozlla Engine)




render to target support mipmaps(refer to bjs)
*** TODO Vertex cache optimization 
refer to <<OpenGL InSights>> 26 chapter: Indexing Multiple Vertex Arrays
This chapter shows a simple solution to convert nonindexed data into an indexed form, allowing its use in an efficient
way with many file formats such as OBJ, X, VRML, and COLLADA. 

refactor obj,md2 indices build?



A number of algorithms can be found in the literature for reorganizing the indices in order to get a better
post-transform cache usage. 
In particular, I recom- mend nvTriStrip, which is slow but ready-to-use, and Tom Forsyth’s
algo- rithm [Forsyth 06], which runs in linear time. 

https://www.opengl.org/discussion_boards/showthread.php/167481-Vertex-cache-optimization

http://tomforsyth1000.github.io/papers/fast_vert_cache_opt.html

https://github.com/vivkin/forsyth
http://www.cnblogs.com/ghl_carmack/p/4107042.html


*** DONE VAO

webgl 2? just use extension in webgl 1!
To save a lot of API calls, use vertex array objects (VAOs) or interleave static vertex data. 




that can significantly improve per- formance on mobile devices

VAOs are available in WebGL 1.0 with the OES_ vertex_array_object
extension, which is widely supported on mobile devices. As of early
2015, more than 80% of smartphone and tablet clients recorded by
WebGL Stats have it 



If vertex array objects (VAOs) are supported, then we build one for
each combination of vertex buffers and index buffer present in the
DrawParameters objects. As we share the buffers between many different
geometries, the actual number of combinations is usually quite
low. This allows us at dispatch time to simplify all the buffer checks
to a single equality comparison between the current VAO and the
previous one. Even when the VAOs are dif- ferent, setting them with
WebGL is cheaper on the CPU than setting all the different buffers and
vertex pointer attributes, which makes them a big win for complex
scenes.


Adding a fallback for devices without VAO support is also
straightforward. Let’s call the code that binds buffers and sets
vertex attrib pointers related to a specific mesh the binding
block. If VAOs are supported, the code should initialize the VAO of
each mesh using the binding block. Then, when the mesh is drawn, the
code either binds the VAO if VAOs are supported, or executes the
binding block if VAOs are not supported. The only case where this
becomes more complicated is when there’s a different number of active
vertex attribute arrays for different meshes—then the code should add
disable- VertexAttribArray calls where appropriate. For a complete
code example, see an explanation of VAOs* or an implementation of a
fallback path in SceneJS
(https://github.com/xeolabs/scenejs/blob/v4.0/src/core/display/chunks/geometryChunk.js)




Lowering the number of vertex buffers helps to reduce CPU usage if
VAOs are not a good fit for the code for some reason. This can be done
by interleaving different types of vertex data for the same object: If
we have, for example, positions, texture coordinates, and normals for
each vertex, they can all be stored in the same vertex buffer in an
interleaved fashion. In our CPU-bound drawing test that uses four
vertex attributes, interleaving the attributes increased the FPS
around 4%. The downside is that interleaving the data needs to be
either handled by the content creation pipeline or done at load time;
the latter may marginally slow down loading. Interleaving three
attributes for a million vertices in a tight JS loop had a cost of
around 200 ms on a Nexus 5 (2013 phone). 




http://blog.tojicode.com/2012/10/oesvertexarrayobject-extension.html

http://www.openglsuperbible.com/2013/12/09/vertex-array-performance/

 

*** TODO optimize from <<WebGL Insights>>

For portability, space requirements of varyings and uniforms within the limits of the GLSL ES spec. Consider using
vec4 variables instead of float arrays, as they potentially allow for tighter packing. See A.7 in the GLSL ES spec. 










When using an RGB framebuffer, always implement a fallback to RGBA for when RGB is not supported. Use
gl.checkFramebufferStatus. 




If shrinking the browser window results in massive speed gains, consider using a half-resolution framebuffer during
mouse interaction. 



Use OES_element_index_uint to draw large indexed models with a single draw call.



need change???
The textureProj GLSL function, vec4 color = textureProj(sampler, uv.xyw);, can be simulated with vec4 color =
texture(sampler, uv.xy/uv.w) 



**** TODO ANGLE optimize(refer to <<WebGL Insights>>=>chapter 1):
- Avoid use of gl.TRIANGLE_FAN, as it may be emulated in software.

- Create new textures, rather than changing the dimensions or format of old ones.
  - if only the pixel data contained in a texture need to be updated, it is best to reuse the texture—the additional
overhead is only incurred when updat- ing texture format or dimensions, because these require redefinition of the mip-
map chain. 

- Do Not Perform Clears with Scissors or Masks(color mask,stencil mask) Enabled
so check and warn info when clear

- Avoid Render Wide Lines as Polygons
(ANGLE does not support line widths greater than 1.0, commonly called “wide” lines)




- Avoid Uint8Array Data in Index Buffers


- Avoid 0xFFFF in 16-Bit Index Buffers
  

- Always Specify the Fragment Shader Float Precision

- Do Not Use Rendering Feedback Loops
(In the OpenGL APIs, attempting to write to and sample from the same texture or renderbuffer in a rendering operation is
considered a rendering feedback loop)


- Don’t Use Extensions without Having a Fallback Path

- Use Immutable Textures When Available (use EXT_texture_storage extension to use texStorage* command instead of
  texImage* command)
Historically, OpenGL and WebGL textures had to be created one mip level at a time. OpenGL does this via glTexImage*, a
method that allows users to cre- ate internally inconsistent textures, considered by the GL to be “incomplete.” This
same method is what is available to developers in WebGL, as texImage*. By contrast, Direct3D requires that users define
the dimensions and format of their entire textures at texture creation time, and it enforces internal consistency. 

Because of this difference, ANGLE must do a considerable amount of bookkeep- ing and maintain system memory copies of
all texture data. The ability to define an entire texture at creation time did later get introduced to OpenGL and its
related APIs as immutable textures, which also enforce internal consistency and disallow changes to dimensions and
format. Immutable textures came to OpenGL ES 2.0 with EXT_texture_storage [Khronos 13a], and they are included in the
core OpenGL ES 3.0 specification and the WebGL 2 Editor’s Draft specifica- tion. When immutable textures are available
via extension or core specification, some of ANGLE’s bookkeeping can be avoided by using the texStorage* com- mands to
define textures. 


- Use RED Textures instead of LUMINANCE(use EXT_texture_rg extension [Khronos 11] to use the RED and RG formats)
(simply using RED textures in place of LUMINANCE and RG in place of LUMINANCE_ALPHA when using ANGLE with APIs that
support them) 

In WebGL and unextended OpenGL ES 2.0, the only option developers have for expressing single-channel textures is the
LUMINANCE format, and LUMINANCE_ALPHA for two-channel textures. The EXT_texture_rg extension [Khronos 11] adds the RED
and RG formats, and these formats become core functionality in OpenGL ES 3.0. The formats also appear in the WebGL 2
Editor’s Draft specification. Meanwhile, Direct3D 11 has dropped all support for luminance textures, providing only red
and red-green formats [MSDN 14a]. This may seem to be a trivial difference—a channel is a channel—but sampling from a
luminance texture is performed differently than from textures of other formats. The single channel of a luminance
texture is duplicated into the red, green, and blue channels when a sample is performed, while sampling from a RED
texture populates only the red channel with data. Similarly, the second channel of a LUMINANCE_ALPHA and an RG texture
will populate only the alpha and green channels in a sample, respectively. To support luminance formats against Direct3D
11, rather than alter the swizzle behavior in shaders, ANGLE instead expands the texture data to four channels. This
expansion, and the associ- ated additional memory and texture upload performance costs, can be avoided by developers
keen for clock cycles by simply using RED textures in place of LUMINANCE and RG in place of LUMINANCE_ALPHA when using
ANGLE with APIs that support them. 



- Avoid Full-Texture Swizzle
Texture swizzling is an OpenGL ES 3.0 feature which allows a texture’s compo- nents to be sampled in a different order,
using the TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_ SWIZZLE_A texture parameters. This is
most often used to read RGBA textures as BGRA, or vice versa, and can also be used to replicate components as with
luminance textures. This feature is, however, not supported by Direct3D 11. Even though it appears a seemingly simple
operation to perform during the shader translation, it is actually not feasible to determine which textures are sampled
where, because samplers can be passed from function to function as parameters, and the same texture sampling function
can be used to sample various different textures. ANGLE therefore swizzles the texture data itself. This consumes some
memory and incurs some overhead at texture upload. These costs can be avoided by not changing the TEXTURE_SWIZZLE_R,
TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B, and TEXTURE_SWIZZLE_A texture parameters from their defaults. If necessary, use
multiple shader variants to account for dif- ferent texture component orders. 




***** not use

- Avoid Uniform Buffer Binding Offsets
Uniform buffer objects (UBOs), newly added in OpenGL ES 3.0, are bound objects which store uniform data for the use of
GLSL shaders. UBOs offer benefits to developers, including the ability to share uniforms between programs and faster
switching between sets of uniforms. OpenGL ES 3.0 also allows UBOs, much like other buffer objects, to be bound at an
offset into the buffer, rather than just the buffer head. Direct3D, on the other hand, does not support referencing its
analogous structure, constant buffers, until Direct3D 11.1, with the addition of the VSSetConstantBuffers1 method [MSDN
14d]. Offsets are supported with a software workaround on all hardware of lower feature levels. Developers can avoid any
performance penalty associated with this workaround by binding UBOs at offset 0 only. 




***** need more understand!
- Avoid Three-Channel Uint8Array/Uint16Array Data in Vertex Buffers(can use four-channel with Uint32Array data)
Direct3D has limited support for three-channel vertex formats. Only 32-bit three- channel formats (both integer and
float) are supported natively [MSDN 14a]. Other three-channel formats are expanded by ANGLE to four-channel internally
when using a Direct3D backend. If the vertex buffer usage is dynamic, this con- version will be performed each time the
buffer is used in a draw. To avoid the expansion, use four-channel formats with 8- or 16-bit types. 


- Avoid Integer Cube Map Textures
Cube maps with unnormalized integer formats are not supported by Direct3D 11 [MSDN 14c]. The ANGLE team hasn’t
encountered any uses for it, which may be the reason it was left out of D3D11, but it is a feature of OpenGL ES 3.0 and
gets tested by the conformance tests. ANGLE therefore must emulate it in ANGLE’s ESSL to HLSL translator. The cube
texture is replaced by a six- layer 2D array texture, and the face from which to sample, and at what loca- tion, is
manually computed. Rather than unnormalized integer formats, we recommend using normalized integer formats for cube
maps. If integer values are expected, multiply the sampled value by the maximum integer value, and round to the nearest
integer. For example, for signed 16-bit integers: int i = int(round(32767 * f)); 



- Beware of Shadow Lookups in 2D Array Textures
Our final recommendation is a minor one, because the range of hardware affected is relatively small. Shadow comparison
lookups are a feature introduced in OpenGL ES 3.0. These texture lookups can perform prefilter comparison of depth data
contained in a texture against a provided reference value. ES 3.0 also intro- duces new texture types, including 2D
texture arrays. Where these two features intersect, a caveat emerges. Direct3D 11 does support shadow lookups for 2D
tex- ture arrays—but not at feature level 10_0 [MSDN 14e]. For this reason, ANGLE must either exclude feature level 10_0
hardware from ES 3.0 support or implement a workaround, with potential performance penalties. If the latter approach is
cho- sen, developers may encounter performance issues on Direct3D 10.0 hardware. If the former approach is chosen
instead, then OpenGL ES 3.0 would not be avail- able on this hardware at all. 






**** TODO firefox implement webgl(refer to <<WebGL Insights>>=>chapter 2):

- Each drawElements call can only work with one index
type anyway. Keep separate index types in separate element array
buffers. 

Using the same element array buffer with multiple index types only
requires the implementation to maintain separate trees for each type;
there are three pos- sible types so there can be up to three trees to
maintain for a given element array buffer, which multiplies by three
the memory usage and speed overhead. Just don’t do it. There is no
good reason to: Each drawElements call can only work with one index
type anyway. Keep separate index types in separate element array
buffers. 


- So if you don’t need to update a frame, don’t it, don’t even call clear. 

The first conclusion of this discussion is that if you don’t need to
update a frame, avoid- ing re-rendering it will save not only the time
it takes to render it, but also a lot of inter- nal compositing work
and synchronization. So if you don’t need to update a frame, don’t
touch it, don’t even call clear. 

**** TODO refer to <<WebGL Insights>>=>chapter 4:
This means that if we want to expose a property on an object, it’s
faster to make it a public field rather than abstract it behind get
and set methods 



**** TODO refer to <<WebGL Insights>>=>chapter 8(mobile chapter):

An application should not have unnecessary “get” calls of any kind,
especially getError, or frequent calls requiring synchronization like
readPixels, flush, or finish.  


***** Reducing Bandwidth Usage

The more obvious ways to reduce bandwidth are reducing texture or
framebuffer reso- lution.  



optimize full-screen effects
Implementing full-screen effects in an efficient way or avoiding them
altogether can also enable huge bandwidth savings [McCaffrey 12;
Pranckevičius 11]. In particular, it is better to combine different
postprocessing filters into a single shader or add simple post-
processing effects directly into the shaders used to render geometry,
when possible. 



Using lots of small polygons also costs bandwidth on tiler
architectures, since they need to access the vertex data separately
for each tile [Merry 12]. Optimizing models to minimize the vertex and
triangle count helps on these GPUs. 


**** TODO refer to <<WebGL Insights>>=>chapter 10(Turbulenz Engine):

cull lights:
For lights, we may go an extra step by projecting the bounding box
into the screen to calculate how many pixels it would actually light,
discarding the light or disabling its shadows’ maps depending on its
contribution to the scene. 


**** TODO refer to <<WebGL Insights>>=>chapter 14:

When the user spins the model around its turntable using a touch
interface, a smooth frame rate is achieved by rendering to a
low-resolution framebuffer (left). When the user lifts her fingers, we
redraw the model in full resolution (right). 

Listing 14.7 Low-fidelity/high-fidelity modes for glass effect.
MyEngine.Buddha = function() { this.framebuffers = {lo: null, hi: null}; this.textures = {lo: null, hi: null};
};
MyEngine.Buddha.draw = function(gl, turntable) {
var texture, canvas = gl.canvas;
if (turntable.state = = turntable.states.Resting) {
//Use a full-resolution framebuffer:
texture = this.textures.hi; gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.hi); gl.viewport(0, 0, canvas.width, canvas.height);
} else {
//Use a half-resolution framebuffer:
texture = this.textures.lo; gl.bindFramebuffer(gl.FRAMEBUFFER, this.framebuffers.lo); gl.viewport(0, 0, canvas.width/2, canvas.height/2);
}
    //...draw Buddha to offscreen surface...
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindTexture(gl.TEXTURE_2D, texture);
    //...draw fullscreen triangle to canvas...
    gl.bindTexture(gl.TEXTURE_2D, null);
};
￼

** TODO optimize from <<游戏引擎架构>>
资源运行时管理：
通过记录引用数来释放资源（p265)

增量时间：
设置上限（p292)

调试：
//开发绘制直线、坐标轴等调试绘图api

//研究data driven engine(p656)

//改进GameObject=>update:
use batch update(p679)


//sky box:
close depth write(p441)



** TODO reference
http://www.cppblog.com/liangairan/archive/2013/03/23/198749.html

** TODO add debug Panel(second version)
use ui component to draw

refactor:
add DebugDrawer class


add more info like bjs




** TODO improve transform
learn GPU Pro 5=>managing transforms in hierarchy



** TODO advanced defer shading
*** TODO gbuffer
how to dynamic set expand gbuffer's value(e.g. store emission color or not)???
support pass specular(if has specular map) in gbuffer or not in
support pass emission color in gbuffer or not in



defer shading:
send emission color




*** TODO optimize
**** TODO optimize
***** TODO gbuffer optimize
use the least amount of memory by lowering precision, reconstructing position from depth, packing values together, using
different distributions, and so on. 




compressing normals to 2 channels:
http://aras-p.info/texts/CompactNormalStorage.html
e.g. ???
    vec3 normal = vec3(gb0[3], gb1[3], 0.0);
    normal.z = (1.0 - normal.x*normal.x - normal.y*normal.y);
    normal.z *= sign(dot(normal, u_cameraPos - pos));
    normal = normalize(normal);




not store specularColor, keep it be #ffffff:
Another compression optimization is to drop specular color off. Non metals rarely have colored specular and metals does
not have albedo. So for metals you can use albedo as spec color and for non metals you just need single channel specular
intensity. 



reconstructing position from depth



***** TODO use 3d texture for tile defer shading?
to store light index list and light grid

https://github.com/WebGLSamples/WebGL2Samples/blob/master/samples/texture_3d.html
http://www.realtimerendering.com/blog/webgl-2-new-features/

**** TODO tile-based deferred shading?


use depth range optimize


optimize in webgl2:
https://github.com/tiansijie/Tile_Based_WebGL_DeferredShader:
The WebGL 1.0 is not support reading data form depth buffer. We work around this issue using gl.readPixels. Again, the
WebGL only support UNSIGNED_BYTE, which return a very unaccurate result and enormous reduce the frame rate. 


**** TODO stencil optimize

http://ogldev.atspace.co.uk/www/tutorial37/tutorial37.html











** TODO VR
https://zhuanlan.zhihu.com/p/24952120

http://gad.qq.com/article/detail/40819
* Record



* TODO unsolved problem


* TODO need improve



* TODO more
